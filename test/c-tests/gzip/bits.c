/* Generated by Frama-C LTest */
/*
#ifndef 
#define 
#endif
#ifndef 
#define 
#endif
*/
typedef unsigned short uint16_t;
typedef unsigned char uch;
typedef int file_t;
typedef unsigned long size_t;
typedef unsigned short ush;
typedef unsigned long ulg;
typedef unsigned int IPos;
struct config {
   ush good_length ;
   ush max_lazy ;
   ush nice_length ;
   ush max_chain ;
};
typedef struct config config;
typedef unsigned long __uint64_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef long __time_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __syscall_slong_t;
enum __anonenum_2 {
    _ISupper = (1 << 0) << 8,
    _ISlower = (1 << 1) << 8,
    _ISalpha = (1 << 2) << 8,
    _ISdigit = (1 << 3) << 8,
    _ISxdigit = (1 << 4) << 8,
    _ISspace = (1 << 5) << 8,
    _ISprint = (1 << 6) << 8,
    _ISgraph = (1 << 7) << 8,
    _ISblank = (1 << 8) >> 8,
    _IScntrl = (1 << 9) >> 8,
    _ISpunct = (1 << 10) >> 8,
    _ISalnum = (1 << 11) >> 8
};
typedef __time_t time_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[((unsigned int)15 * sizeof(int) - (unsigned int)4 * sizeof(void *)) - sizeof(size_t)] ;
};
struct option {
   char const *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
struct huft;
union __anonunion_v_25 {
   ush n ;
   struct huft *t ;
};
struct huft {
   uch e ;
   uch b ;
   union __anonunion_v_25 v ;
};
struct spec_fd_t {
   int limit ;
   int len ;
   int pos ;
   unsigned char *buf ;
};
union __anonunion_fc_7 {
   ush freq ;
   ush code ;
};
union __anonunion_dl_8 {
   ush dad ;
   ush len ;
};
struct ct_data {
   union __anonunion_fc_7 fc ;
   union __anonunion_dl_8 dl ;
};
typedef struct ct_data ct_data;
struct tree_desc {
   ct_data *dyn_tree ;
   ct_data *static_tree ;
   int *extra_bits ;
   int extra_base ;
   int elems ;
   int max_length ;
   int max_code ;
};
typedef struct tree_desc tree_desc;
typedef void *voidp;
typedef unsigned char char_type;
typedef long code_int;
typedef struct _IO_FILE _IO_FILE;
struct hufts;
/* compiler builtin: 
   int __builtin_bswap32(int);   */
/* compiler builtin: 
   int __builtin_bswap64(int);   */
uch outbuf[16384 + 2048];
unsigned int outcnt;
int file_read(char *buf, unsigned int size) __attribute__((__FC_OLDSTYLEPROTO__));

void bi_init(file_t zipfile) __attribute__((__FC_OLDSTYLEPROTO__));

void send_bits(int value, int length) __attribute__((__FC_OLDSTYLEPROTO__));

unsigned int bi_reverse(unsigned int code, int len) __attribute__((__FC_OLDSTYLEPROTO__));

void bi_windup(void);

void copy_block(char *buf, unsigned int len, int header) __attribute__((
__FC_OLDSTYLEPROTO__));

int (*read_buf)(char *buf, unsigned int size);
void flush_outbuf(void);

static file_t zfile;
static unsigned short bi_buf = (unsigned short)0;
static int bi_valid = 0;
void bi_init(file_t zipfile) __attribute__((__FC_OLDSTYLEPROTO__));;
void bi_init(file_t zipfile)
{
  zfile = zipfile;
  bi_buf = (unsigned short)0;
  bi_valid = 0;
  
  
  if (zfile != -1) read_buf = & file_read;
  return;
}

void send_bits(int value, int length) __attribute__((__FC_OLDSTYLEPROTO__));;
void send_bits(int value, int length)
{
  
  if (bi_valid > (int)((unsigned int)(8 * 2) * sizeof(char)) - length) {
    bi_buf = (unsigned short)((int)bi_buf | (value << bi_valid));
    
    
    if (outcnt < (unsigned int)(16384 - 2)) {
      unsigned int tmp;
      unsigned int tmp_0;
      tmp = outcnt;
      outcnt ++;
      outbuf[tmp] = (unsigned char)((int)bi_buf & 0xff);
      tmp_0 = outcnt;
      outcnt ++;
      outbuf[tmp_0] = (unsigned char)((int)bi_buf >> 8);
    }
    else {
      {
        unsigned int tmp_1;
        tmp_1 = outcnt;
        outcnt ++;
        outbuf[tmp_1] = (unsigned char)((int)bi_buf & 0xff);
        
        
        if (outcnt == (unsigned int)16384) flush_outbuf();
      }
      {
        unsigned int tmp_2;
        tmp_2 = outcnt;
        outcnt ++;
        outbuf[tmp_2] = (unsigned char)((int)bi_buf >> 8);
        
        
        if (outcnt == (unsigned int)16384) flush_outbuf();
      }
    }
    bi_buf = (unsigned short)((int)((unsigned short)value) >> ((unsigned int)(
                                                               8 * 2) * sizeof(char) - (unsigned int)bi_valid));
    bi_valid = (int)((unsigned int)bi_valid + ((unsigned int)length - 
                                               (unsigned int)(8 * 2) * sizeof(char)));
  }
  else {
    bi_buf = (unsigned short)((int)bi_buf | (value << bi_valid));
    bi_valid += length;
  }
  return;
}

unsigned int bi_reverse(unsigned int code, int len) __attribute__((__FC_OLDSTYLEPROTO__));;
unsigned int bi_reverse(unsigned int code, int len)
{
  unsigned int __retres;
  register unsigned int res;
  res = (unsigned int)0;
  while (1) {
    res |= code & (unsigned int)1;
    code >>= 1;
    res <<= 1;
    len --;
    
    
    if (! (len > 0)) break;
  }
  __retres = res >> 1;
  return __retres;
}

void bi_windup(void)
{
  
  
  if (bi_valid > 8) {
    
    
    if (outcnt < (unsigned int)(16384 - 2)) {
      unsigned int tmp;
      unsigned int tmp_0;
      tmp = outcnt;
      outcnt ++;
      outbuf[tmp] = (unsigned char)((int)bi_buf & 0xff);
      tmp_0 = outcnt;
      outcnt ++;
      outbuf[tmp_0] = (unsigned char)((int)bi_buf >> 8);
    }
    else {
      {
        unsigned int tmp_1;
        tmp_1 = outcnt;
        outcnt ++;
        outbuf[tmp_1] = (unsigned char)((int)bi_buf & 0xff);
        
        
        if (outcnt == (unsigned int)16384) flush_outbuf();
      }
      {
        unsigned int tmp_2;
        tmp_2 = outcnt;
        outcnt ++;
        outbuf[tmp_2] = (unsigned char)((int)bi_buf >> 8);
        
        
        if (outcnt == (unsigned int)16384) flush_outbuf();
      }
    }
  }
  else {
    
    
    if (bi_valid > 0) {
      unsigned int tmp_3;
      tmp_3 = outcnt;
      outcnt ++;
      outbuf[tmp_3] = (unsigned char)bi_buf;
      
      
      if (outcnt == (unsigned int)16384) flush_outbuf();
    }
  }
  bi_buf = (unsigned short)0;
  bi_valid = 0;
  return;
}

void copy_block(char *buf, unsigned int len, int header) __attribute__((
__FC_OLDSTYLEPROTO__));;
void copy_block(char *buf, unsigned int len, int header)
{
  bi_windup();
  
  
  if (header) {
    
    
    if (outcnt < (unsigned int)(16384 - 2)) {
      unsigned int tmp;
      unsigned int tmp_0;
      tmp = outcnt;
      outcnt ++;
      outbuf[tmp] = (unsigned char)((int)((unsigned short)len) & 0xff);
      tmp_0 = outcnt;
      outcnt ++;
      outbuf[tmp_0] = (unsigned char)((int)((unsigned short)len) >> 8);
    }
    else {
      {
        unsigned int tmp_1;
        tmp_1 = outcnt;
        outcnt ++;
        outbuf[tmp_1] = (unsigned char)((int)((unsigned short)len) & 0xff);
        
        
        if (outcnt == (unsigned int)16384) flush_outbuf();
      }
      {
        unsigned int tmp_2;
        tmp_2 = outcnt;
        outcnt ++;
        outbuf[tmp_2] = (unsigned char)((int)((unsigned short)len) >> 8);
        
        
        if (outcnt == (unsigned int)16384) flush_outbuf();
      }
    }
    
    
    if (outcnt < (unsigned int)(16384 - 2)) {
      unsigned int tmp_3;
      unsigned int tmp_4;
      tmp_3 = outcnt;
      outcnt ++;
      outbuf[tmp_3] = (unsigned char)((int)((unsigned short)(~ len)) & 0xff);
      tmp_4 = outcnt;
      outcnt ++;
      outbuf[tmp_4] = (unsigned char)((int)((unsigned short)(~ len)) >> 8);
    }
    else {
      {
        unsigned int tmp_5;
        tmp_5 = outcnt;
        outcnt ++;
        outbuf[tmp_5] = (unsigned char)((int)((unsigned short)(~ len)) & 0xff);
        
        
        if (outcnt == (unsigned int)16384) flush_outbuf();
      }
      {
        unsigned int tmp_6;
        tmp_6 = outcnt;
        outcnt ++;
        outbuf[tmp_6] = (unsigned char)((int)((unsigned short)(~ len)) >> 8);
        
        
        if (outcnt == (unsigned int)16384) flush_outbuf();
      }
    }
  }
  while (1) {
    {
      unsigned int tmp_9;
      tmp_9 = len;
      len --;
      
      
      if (! tmp_9) break;
      {
        unsigned int tmp_7;
        char *tmp_8;
        tmp_7 = outcnt;
        outcnt ++;
        tmp_8 = buf;
        buf ++;
        outbuf[tmp_7] = (unsigned char)*tmp_8;
        
        
        if (outcnt == (unsigned int)16384) flush_outbuf();
      }
    }
  }
  return;
}

/*@ assigns *((char *)__dest); */
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict __dest,
                                                  void const * __restrict __src,
                                                  size_t __n) __attribute__((
__nonnull__(1,2), __leaf__));

/*@ assigns *((char *)__s); */
extern  __attribute__((__nothrow__)) void *memset(void *__s, int __c,
                                                  size_t __n) __attribute__((
__nonnull__(1), __leaf__));

/*@ assigns \nothing; */
extern char *convert_spec_fd_ts_sint8s(struct spec_fd_t *inbuf);

uch window[2L * (long)0x8000];
/*@ assigns \nothing; */
extern char *convert_uint8s_sint8s(unsigned char *inbuf);

ush prev[1L << 16];
/*@ assigns \nothing; */
extern char *convert_charss_sint8s(char **in);

void lm_init(int pack_level, ush *flags_0) __attribute__((__FC_OLDSTYLEPROTO__));

/*@ assigns \nothing; */
extern unsigned char *convert_sint8s_uint8s(char *inbuf);

ulg deflate(void);

/*@ assigns \nothing; */
extern struct hufts *convert_sint8s_hufts(char *inbuf);

int ct_tally(int dist, int lc) __attribute__((__FC_OLDSTYLEPROTO__));

/*@ assigns \nothing; */
extern char *convert_uint32s_sint8s(unsigned int *inbuf);

ulg flush_block(char *buf, ulg stored_len, int eof) __attribute__((__FC_OLDSTYLEPROTO__));

/*@ assigns \nothing; */
extern char *convert_hufts_sint8s(struct hufts *inbuf);

void error(char *m) __attribute__((__FC_OLDSTYLEPROTO__));

/*@ assigns \nothing; */
extern char *convert_uint16s_sint8s(uint16_t *inbuf);

/*@ assigns \nothing; */
extern unsigned char *convert_uint16s_uint8s(uint16_t *inbuf);

ulg window_size = (unsigned long)2 * (unsigned long)0x8000;
long block_start;
static unsigned int ins_h;
unsigned int prev_length;
unsigned int strstart;
unsigned int match_start;
static int eofile;
static unsigned int lookahead;
unsigned int max_chain_length;
static unsigned int max_lazy_match;
static int compr_level;
unsigned int good_match;
int nice_match;
static config configuration_table[10] =   
                                          {{.good_length = (unsigned short)0,
                                            .max_lazy = (unsigned short)0,
                                            .nice_length = (unsigned short)0,
                                            .max_chain = (unsigned short)0},
                                           {.good_length = (unsigned short)4,
                                            .max_lazy = (unsigned short)4,
                                            .nice_length = (unsigned short)8,
                                            .max_chain = (unsigned short)4},
                                           {.good_length = (unsigned short)4,
                                            .max_lazy = (unsigned short)5,
                                            .nice_length = (unsigned short)16,
                                            .max_chain = (unsigned short)8},
                                           {.good_length = (unsigned short)4,
                                            .max_lazy = (unsigned short)6,
                                            .nice_length = (unsigned short)32,
                                            .max_chain = (unsigned short)32},
                                           {.good_length = (unsigned short)4,
                                            .max_lazy = (unsigned short)4,
                                            .nice_length = (unsigned short)16,
                                            .max_chain = (unsigned short)16},
                                           {.good_length = (unsigned short)8,
                                            .max_lazy = (unsigned short)16,
                                            .nice_length = (unsigned short)32,
                                            .max_chain = (unsigned short)32},
                                           {.good_length = (unsigned short)8,
                                            .max_lazy = (unsigned short)16,
                                            .nice_length = (unsigned short)128,
                                            .max_chain = (unsigned short)128},
                                           {.good_length = (unsigned short)8,
                                            .max_lazy = (unsigned short)32,
                                            .nice_length = (unsigned short)128,
                                            .max_chain = (unsigned short)256},
                                           {.good_length = (unsigned short)32,
                                            .max_lazy = (unsigned short)128,
                                            .nice_length = (unsigned short)258,
                                            .max_chain = (unsigned short)1024},
                                           {.good_length = (unsigned short)32,
                                            .max_lazy = (unsigned short)258,
                                            .nice_length = (unsigned short)258,
                                            .max_chain = (unsigned short)4096}};
static void fill_window(void);

/*@ assigns \nothing; */
extern struct huft *convert_sint8s_huft(char *inbuf);

static ulg deflate_fast(void);

int longest_match(IPos cur_match) __attribute__((__FC_OLDSTYLEPROTO__));

void lm_init(int pack_level, ush *flags_0) __attribute__((__FC_OLDSTYLEPROTO__));;
void lm_init(int pack_level, ush *flags_0)
{
  register unsigned int j_0;
  int tmp_0;
  unsigned int tmp;
  char *tmp_1;
  
  
  
  
  if (pack_level < 1 || pack_level > 9) error((char *)"bad pack level");
  compr_level = pack_level;
  tmp_1 = convert_uint16s_sint8s(& prev[0x8000]);
  memset((void *)tmp_1,0,
         (unsigned long)((unsigned int)(1 << 15) * sizeof(prev[0x8000])));
  max_lazy_match = (unsigned int)configuration_table[pack_level].max_lazy;
  good_match = (unsigned int)configuration_table[pack_level].good_length;
  nice_match = (int)configuration_table[pack_level].nice_length;
  max_chain_length = (unsigned int)configuration_table[pack_level].max_chain;
  
  
  if (pack_level == 1) *flags_0 = (unsigned short)((int)*flags_0 | 4);
  else {
    
    
    if (pack_level == 9) *flags_0 = (unsigned short)((int)*flags_0 | 2);
  }
  strstart = (unsigned int)0;
  block_start = 0L;
  
  
  if (sizeof(int) <= (unsigned int)2) tmp = (unsigned int)0x8000;
  else tmp = (unsigned int)(2 * 0x8000);
  tmp_0 = (*read_buf)((char *)(window),tmp);
  lookahead = (unsigned int)tmp_0;
  
  
  
  
  if (lookahead == (unsigned int)0 || lookahead == (unsigned int)(-1)) {
    eofile = 1;
    lookahead = (unsigned int)0;
    goto return_label;
  }
  eofile = 0;
  while (1) {
    
    
    
    
    if (! (lookahead < (unsigned int)((258 + 3) + 1) && ! eofile)) break;
    fill_window();
  }
  ins_h = (unsigned int)0;
  j_0 = (unsigned int)0;
  while (1) {
    
    
    if (! (j_0 < (unsigned int)(3 - 1))) break;
    ins_h = ((ins_h << ((15 + 3) - 1) / 3) ^ (unsigned int)window[j_0]) & (
            (unsigned int)(1 << 15) - (unsigned int)1);
    j_0 ++;
  }
  return_label: ;
  return;
}

int longest_match(IPos cur_match) __attribute__((__FC_OLDSTYLEPROTO__));;
int longest_match(IPos cur_match)
{
  unsigned int chain_length;
  register uch *scan;
  register uch *match;
  register int len;
  int best_len;
  IPos limit;
  unsigned int tmp;
  register uch *strend;
  register uch scan_end1;
  register uch scan_end;
  chain_length = max_chain_length;
  scan = & window[strstart];
  best_len = (int)prev_length;
  
  
  if (strstart > (unsigned int)(0x8000 - ((258 + 3) + 1))) tmp = strstart - (unsigned int)(
                                                                 0x8000 - (
                                                                 (258 + 3) + 1));
  else tmp = (unsigned int)0;
  limit = tmp;
  strend = & window[strstart] + 258;
  scan_end1 = *(scan + (best_len - 1));
  scan_end = *(scan + best_len);
  
  
  if (prev_length >= good_match) chain_length >>= 2;
  while (1) {
    match = & window[cur_match];
    
    
    
    
    
    
    if (((int)*(match + best_len) != (int)scan_end || (int)*(match + (
                                                             best_len - 1)) != (int)scan_end1) || 
        (int)*match != (int)*scan) goto __Cont;
    else {
      match ++;
      
      
      if ((int)*match != (int)*(scan + 1)) goto __Cont;
    }
    scan += 2;
    match ++;
    while (1) {
      scan ++;
      match ++;
      
      
      if ((int)*scan == (int)*match) {
        scan ++;
        match ++;
        
        
        if ((int)*scan == (int)*match) {
          scan ++;
          match ++;
          
          
          if ((int)*scan == (int)*match) {
            scan ++;
            match ++;
            
            
            if ((int)*scan == (int)*match) {
              scan ++;
              match ++;
              
              
              if ((int)*scan == (int)*match) {
                scan ++;
                match ++;
                
                
                if ((int)*scan == (int)*match) {
                  scan ++;
                  match ++;
                  
                  
                  if ((int)*scan == (int)*match) {
                    scan ++;
                    match ++;
                    
                    
                    if ((int)*scan == (int)*match) {
                      
                      
                      if (! (scan < strend)) break;
                    }
                    else break;
                  }
                  else break;
                }
                else break;
              }
              else break;
            }
            else break;
          }
          else break;
        }
        else break;
      }
      else break;
    }
    len = 258 - (strend - scan);
    scan = strend - 258;
    
    
    if (len > best_len) {
      match_start = cur_match;
      best_len = len;
      
      
      if (len >= nice_match) break;
      scan_end1 = *(scan + (best_len - 1));
      scan_end = *(scan + best_len);
    }
    __Cont:
      cur_match = (unsigned int)prev[cur_match & (unsigned int)(0x8000 - 1)];
    
    
    if (cur_match > limit) {
      chain_length --;
      
      
      if (! (chain_length != (unsigned int)0)) break;
    }
    else break;
  }
  return best_len;
}

static void fill_window(void)
{
  register unsigned int n;
  register unsigned int m;
  unsigned int more;
  more = (unsigned int)((window_size - (unsigned long)lookahead) - (unsigned long)strstart);
  
  
  if (more == (unsigned int)(-1)) more --;
  else {
    
    if (strstart >= (unsigned int)(0x8000 + (0x8000 - ((258 + 3) + 1)))) {
      char *tmp;
      char *tmp_0;
      {
        /*sequence*/
        tmp = convert_uint8s_sint8s(window);
        tmp_0 = convert_uint8s_sint8s(window);
      }
      memcpy((void *)tmp_0,(void const *)(tmp + 0x8000),
             (unsigned long)((unsigned int)0x8000));
      match_start -= (unsigned int)0x8000;
      strstart -= (unsigned int)0x8000;
      block_start -= (long)0x8000;
      n = (unsigned int)0;
      while (1) {
        
        
        if (! (n < (unsigned int)(1 << 15))) break;
        {
          unsigned int tmp_1;
          m = (unsigned int)*(& prev[0x8000] + n);
          
          
          if (m >= (unsigned int)0x8000) tmp_1 = m - (unsigned int)0x8000;
          else tmp_1 = (unsigned int)0;
          *(& prev[0x8000] + n) = (unsigned short)tmp_1;
        }
        n ++;
      }
      n = (unsigned int)0;
      while (1) {
        
        
        if (! (n < (unsigned int)0x8000)) break;
        {
          unsigned int tmp_2;
          m = (unsigned int)prev[n];
          
          
          if (m >= (unsigned int)0x8000) tmp_2 = m - (unsigned int)0x8000;
          else tmp_2 = (unsigned int)0;
          prev[n] = (unsigned short)tmp_2;
        }
        n ++;
      }
      more += (unsigned int)0x8000;
    }
  }
  
  
  if (! eofile) {
    int tmp_3;
    tmp_3 = (*read_buf)(((char *)(window) + strstart) + lookahead,more);
    n = (unsigned int)tmp_3;
    
    
    
    
    if (n == (unsigned int)0 || n == (unsigned int)(-1)) eofile = 1;
    else lookahead += n;
  }
  return;
}

static ulg deflate_fast(void)
{
  IPos hash_head;
  int flush;
  unsigned int match_length;
  ulg tmp_2;
  char *tmp_1;
  match_length = (unsigned int)0;
  prev_length = (unsigned int)(3 - 1);
  while (1) {
    
    
    if (! (lookahead != (unsigned int)0)) break;
    ins_h = ((ins_h << ((15 + 3) - 1) / 3) ^ (unsigned int)window[(strstart + (unsigned int)3) - (unsigned int)1]) & (
            (unsigned int)(1 << 15) - (unsigned int)1);
    hash_head = (unsigned int)*(& prev[0x8000] + ins_h);
    prev[strstart & (unsigned int)(0x8000 - 1)] = (unsigned short)hash_head;
    *(& prev[0x8000] + ins_h) = (unsigned short)strstart;
    
    
    
    if (hash_head != (unsigned int)0 && strstart - hash_head <= (unsigned int)(
                                        0x8000 - ((258 + 3) + 1))) {
      int tmp;
      tmp = longest_match(hash_head);
      match_length = (unsigned int)tmp;
      
      
      if (match_length > lookahead) match_length = lookahead;
    }
    
    
    if (match_length >= (unsigned int)3) {
      flush = ct_tally((int)(strstart - match_start),
                       (int)(match_length - (unsigned int)3));
      lookahead -= match_length;
      
      
      if (match_length <= max_lazy_match) {
        match_length --;
        while (1) {
          strstart ++;
          ins_h = ((ins_h << ((15 + 3) - 1) / 3) ^ (unsigned int)window[
                   (strstart + (unsigned int)3) - (unsigned int)1]) & (
                  (unsigned int)(1 << 15) - (unsigned int)1);
          hash_head = (unsigned int)*(& prev[0x8000] + ins_h);
          prev[strstart & (unsigned int)(0x8000 - 1)] = (unsigned short)hash_head;
          *(& prev[0x8000] + ins_h) = (unsigned short)strstart;
          match_length --;
          
          
          if (! (match_length != (unsigned int)0)) break;
        }
        strstart ++;
      }
      else {
        strstart += match_length;
        match_length = (unsigned int)0;
        ins_h = (unsigned int)window[strstart];
        ins_h = ((ins_h << ((15 + 3) - 1) / 3) ^ (unsigned int)window[
                 strstart + (unsigned int)1]) & ((unsigned int)(1 << 15) - (unsigned int)1);
      }
    }
    else {
      flush = ct_tally(0,(int)window[strstart]);
      lookahead --;
      strstart ++;
    }
    
    
    if (flush) {
      char *tmp_0;
      
      
      if (block_start >= 0L) tmp_0 = convert_uint8s_sint8s(& window[(unsigned int)block_start]);
      else tmp_0 = (char *)((void *)0);
      flush_block(tmp_0,(unsigned long)((long)strstart - block_start),0);
      block_start = (long)strstart;
    }
    while (1) {
      
      
      
      
      if (! (lookahead < (unsigned int)((258 + 3) + 1) && ! eofile)) 
        break;
      fill_window();
    }
  }
  
  
  if (block_start >= 0L) tmp_1 = convert_uint8s_sint8s(& window[(unsigned int)block_start]);
  else tmp_1 = (char *)((void *)0);
  tmp_2 = flush_block(tmp_1,(unsigned long)((long)strstart - block_start),1);
  return tmp_2;
}

ulg deflate(void)
{
  ulg __retres;
  IPos hash_head;
  IPos prev_match;
  int flush;
  int match_available;
  register unsigned int match_length;
  ulg tmp_5;
  char *tmp_4;
  match_available = 0;
  match_length = (unsigned int)(3 - 1);
  
  
  if (compr_level <= 3) {
    ulg tmp;
    tmp = deflate_fast();
    __retres = tmp;
    goto return_label;
  }
  while (1) {
    
    
    if (! (lookahead != (unsigned int)0)) break;
    ins_h = ((ins_h << ((15 + 3) - 1) / 3) ^ (unsigned int)window[(strstart + (unsigned int)3) - (unsigned int)1]) & (
            (unsigned int)(1 << 15) - (unsigned int)1);
    hash_head = (unsigned int)*(& prev[0x8000] + ins_h);
    prev[strstart & (unsigned int)(0x8000 - 1)] = (unsigned short)hash_head;
    *(& prev[0x8000] + ins_h) = (unsigned short)strstart;
    prev_length = match_length;
    prev_match = match_start;
    match_length = (unsigned int)(3 - 1);
    
    
    
    
    

    

    if ((hash_head != (unsigned int)0 && prev_length < max_lazy_match) && 
        strstart - hash_head <= (unsigned int)(0x8000 - ((258 + 3) + 1))) {
      int tmp_0;
      tmp_0 = longest_match(hash_head);
      match_length = (unsigned int)tmp_0;
      
      
      if (match_length > lookahead) match_length = lookahead;
      
      
      
      
      if (match_length == (unsigned int)3 && strstart - match_start > (unsigned int)4096) 
        match_length --;
    }
    
    
    
    
    if (prev_length >= (unsigned int)3 && match_length <= prev_length) {
      flush = ct_tally((int)((strstart - (unsigned int)1) - prev_match),
                       (int)(prev_length - (unsigned int)3));
      lookahead -= prev_length - (unsigned int)1;
      prev_length -= (unsigned int)2;
      while (1) {
        strstart ++;
        ins_h = ((ins_h << ((15 + 3) - 1) / 3) ^ (unsigned int)window[
                 (strstart + (unsigned int)3) - (unsigned int)1]) & (
                (unsigned int)(1 << 15) - (unsigned int)1);
        hash_head = (unsigned int)*(& prev[0x8000] + ins_h);
        prev[strstart & (unsigned int)(0x8000 - 1)] = (unsigned short)hash_head;
        *(& prev[0x8000] + ins_h) = (unsigned short)strstart;
        prev_length --;
        
        
        if (! (prev_length != (unsigned int)0)) break;
      }
      match_available = 0;
      match_length = (unsigned int)(3 - 1);
      strstart ++;
      
      
      if (flush) {
        char *tmp_1;
        
        
        if (block_start >= 0L) tmp_1 = convert_uint8s_sint8s(& window[(unsigned int)block_start]);
        else tmp_1 = (char *)((void *)0);
        flush_block(tmp_1,(unsigned long)((long)strstart - block_start),0);
        block_start = (long)strstart;
      }
    }
    else {
      
      
      if (match_available) {
        int tmp_3;
        tmp_3 = ct_tally(0,(int)window[strstart - (unsigned int)1]);
        
        
        if (tmp_3) {
          char *tmp_2;
          
          
          if (block_start >= 0L) tmp_2 = convert_uint8s_sint8s(& window[(unsigned int)block_start]);
          else tmp_2 = (char *)((void *)0);
          flush_block(tmp_2,(unsigned long)((long)strstart - block_start),0);
          block_start = (long)strstart;
        }
        strstart ++;
        lookahead --;
      }
      else {
        match_available = 1;
        strstart ++;
        lookahead --;
      }
    }
    while (1) {
      
      
      
      
      if (! (lookahead < (unsigned int)((258 + 3) + 1) && ! eofile)) 
        break;
      fill_window();
    }
  }
  
  
  if (match_available) ct_tally(0,(int)window[strstart - (unsigned int)1]);
  
  
  if (block_start >= 0L) tmp_4 = convert_uint8s_sint8s(& window[(unsigned int)block_start]);
  else tmp_4 = (char *)((void *)0);
  tmp_5 = flush_block(tmp_4,(unsigned long)((long)strstart - block_start),1);
  __retres = tmp_5;
  return_label: ;
  return __retres;
}

static char *license_msg[15] =   
                                 {(char *)"   Copyright (C) 1992-1993 Jean-loup Gailly",
                                  (char *)"   This program is free software; you can redistribute it and/or modify",
                                  (char *)"   it under the terms of the GNU General Public License as published by",
                                  (char *)"   the Free Software Foundation; either version 2, or (at your option)",
                                  (char *)"   any later version.",
                                  (char *)"",
                                  (char *)"   This program is distributed in the hope that it will be useful,",
                                  (char *)"   but WITHOUT ANY WARRANTY; without even the implied warranty of",
                                  (char *)"   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
                                  (char *)"   GNU General Public License for more details.",
                                  (char *)"",
                                  (char *)"   You should have received a copy of the GNU General Public License",
                                  (char *)"   along with this program; if not, write to the Free Software",
                                  (char *)"   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.",
                                  (char *)0};
__inline static unsigned int __bswap_32(unsigned int __bsx)
{
  unsigned int __retres;
  int tmp;
  tmp = __builtin_bswap32((int)__bsx);
  __retres = (unsigned int)tmp;
  return __retres;
}

__inline static __uint64_t __bswap_64(__uint64_t __bsx)
{
  __uint64_t __retres;
  int tmp;
  tmp = __builtin_bswap64((int)__bsx);
  __retres = (unsigned long)tmp;
  return __retres;
}

/*@ assigns \nothing; */
extern  __attribute__((__nothrow__)) unsigned short const **__ctype_b_loc(
void) __attribute__((__leaf__, __const__));

/*@ assigns *__buf; */
extern  __attribute__((__nothrow__)) int stat(char const * __restrict __file,
                                              struct stat * __restrict __buf) __attribute__((
__nonnull__(1,2), __leaf__));

/*@ assigns *__buf; */
extern  __attribute__((__nothrow__)) int fstat(int __fd, struct stat *__buf) __attribute__((
__nonnull__(2), __leaf__));

/*@ assigns *__buf; */
extern  __attribute__((__nothrow__)) int lstat(char const * __restrict __file,
                                               struct stat * __restrict __buf) __attribute__((
__nonnull__(1,2), __leaf__));

/*@ assigns \nothing; */
extern  __attribute__((__nothrow__)) int chmod(char const *__file,
                                               __mode_t __mode) __attribute__((
__nonnull__(1), __leaf__));

/*@ assigns \nothing; */
extern  __attribute__((__nothrow__)) int *__errno_location(void) __attribute__((
__leaf__, __const__));

int spec_read(int fd, unsigned char *buf, int size);

extern struct _IO_FILE *stdin;

extern struct _IO_FILE *stdout;

extern struct _IO_FILE *stderr;

/*@ assigns *__stream; */
extern int fflush(FILE *__stream);

/*@ assigns *__stream; */
extern int fprintf(FILE * __restrict __stream,
                   char const * __restrict __format , ...);

/*@ assigns \nothing; */
extern int printf(char const * __restrict __format , ...);

/*@ assigns *__s, *__stream; */
extern char *fgets(char * __restrict __s, int __n, FILE * __restrict __stream);

/*@ assigns \nothing; */
extern void perror(char const *__s);

/*@ assigns *__stream; */
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream) __attribute__((
__leaf__));

/*@ assigns \nothing; */
extern  __attribute__((__nothrow__)) int memcmp(void const *__s1,
                                                void const *__s2, size_t __n) __attribute__((
__pure__, __nonnull__(1,2), __leaf__));

/*@ assigns *__dest; */
extern  __attribute__((__nothrow__)) char *strcpy(char * __restrict __dest,
                                                  char const * __restrict __src) __attribute__((
__nonnull__(1,2), __leaf__));

/*@ assigns *__dest; */
extern  __attribute__((__nothrow__)) char *strcat(char * __restrict __dest,
                                                  char const * __restrict __src) __attribute__((
__nonnull__(1,2), __leaf__));

/*@ assigns \nothing; */
extern  __attribute__((__nothrow__)) int strcmp(char const *__s1,
                                                char const *__s2) __attribute__((
__pure__, __nonnull__(1,2), __leaf__));

/*@ assigns \nothing; */
extern  __attribute__((__nothrow__)) char *strrchr(char const *__s, int __c) __attribute__((
__pure__, __nonnull__(1), __leaf__));

/*@ assigns \nothing; */
extern  __attribute__((__nothrow__)) size_t strcspn(char const *__s,
                                                    char const *__reject) __attribute__((
__pure__, __nonnull__(1,2), __leaf__));

/*@ assigns \nothing; */
extern  __attribute__((__nothrow__)) size_t strlen(char const *__s) __attribute__((
__pure__, __nonnull__(1), __leaf__));

int method;

uch inbuf[0x8000 + 64];
ush d_buf[0x8000];
unsigned int insize;
unsigned int inptr;
long bytes_in;
long bytes_out;
long header_bytes;
int ifd;
int ofd;
char ifname[1024];
char ofname[1024];
char *progname;
long time_stamp;
long ifile_size;
int exit_code;

int verbose;

int quiet;

int level;

int test;

int to_stdout;

int save_orig_name;
int zip(int in, int out) __attribute__((__FC_OLDSTYLEPROTO__));

int unzip(int in, int out) __attribute__((__FC_OLDSTYLEPROTO__));

int check_zipfile(int in) __attribute__((__FC_OLDSTYLEPROTO__));

int unpack(int in, int out) __attribute__((__FC_OLDSTYLEPROTO__));

int unlzh(int in, int out) __attribute__((__FC_OLDSTYLEPROTO__));

void abort_gzip(void);

int copy(int in, int out) __attribute__((__FC_OLDSTYLEPROTO__));

void clear_bufs(void);

int fill_inbuf(int eof_ok) __attribute__((__FC_OLDSTYLEPROTO__));

char *strlwr(char *s) __attribute__((__FC_OLDSTYLEPROTO__));

char *gzipbasename(char *fname) __attribute__((__FC_OLDSTYLEPROTO__));

void read_error(void);

void write_error(void);

void display_ratio(long num, long den, FILE *file) __attribute__((__FC_OLDSTYLEPROTO__));

int maxbits;

int unlzw(int in, int out) __attribute__((__FC_OLDSTYLEPROTO__));

/*@ assigns \nothing; */
extern  __attribute__((__nothrow__)) char *ctime(time_t const *__timer) __attribute__((
__leaf__));

/*@ assigns \nothing; */
extern int open(char const *__file, int __oflag , ...) __attribute__((
__nonnull__(1)));

/*@ assigns *((char *)__ptr); */
extern  __attribute__((__nothrow__)) void free(void *__ptr) __attribute__((
__leaf__));

/*@ assigns \nothing; */
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status) __attribute__((
__leaf__));

int ascii = 0;
int to_stdout = 0;
int decompress = 0;
int force = 0;
int no_name = -1;
int no_time = -1;
int recursive = 0;
int list = 0;
int verbose = 0;
int quiet = 0;
int do_lzw = 0;
int test = 0;
int foreground;
int maxbits = 16;
int method = 8;
int level = 6;
int exit_code = 0;
int last_member;
int part_nb;
char *env;
char **args = (char **)0;
char z_suffix[30 + 1];
int z_len;
long total_in = (long)0;
long total_out = (long)0;
int remove_ofname = 0;
struct stat istat;
struct option longopts[24] =   
                               {{.name = "ascii", .has_arg = 0,
                                 .flag = (int *)0, .val = 'a'},
                                {.name = "to-stdout", .has_arg = 0,
                                 .flag = (int *)0, .val = 'c'},
                                {.name = "stdout", .has_arg = 0,
                                 .flag = (int *)0, .val = 'c'},
                                {.name = "decompress", .has_arg = 0,
                                 .flag = (int *)0, .val = 'd'},
                                {.name = "uncompress", .has_arg = 0,
                                 .flag = (int *)0, .val = 'd'},
                                {.name = "force", .has_arg = 0,
                                 .flag = (int *)0, .val = 'f'},
                                {.name = "help", .has_arg = 0,
                                 .flag = (int *)0, .val = 'h'},
                                {.name = "list", .has_arg = 0,
                                 .flag = (int *)0, .val = 'l'},
                                {.name = "license", .has_arg = 0,
                                 .flag = (int *)0, .val = 'L'},
                                {.name = "no-name", .has_arg = 0,
                                 .flag = (int *)0, .val = 'n'},
                                {.name = "name", .has_arg = 0,
                                 .flag = (int *)0, .val = 'N'},
                                {.name = "quiet", .has_arg = 0,
                                 .flag = (int *)0, .val = 'q'},
                                {.name = "silent", .has_arg = 0,
                                 .flag = (int *)0, .val = 'q'},
                                {.name = "recursive", .has_arg = 0,
                                 .flag = (int *)0, .val = 'r'},
                                {.name = "suffix", .has_arg = 1,
                                 .flag = (int *)0, .val = 'S'},
                                {.name = "test", .has_arg = 0,
                                 .flag = (int *)0, .val = 't'},
                                {.name = "no-time", .has_arg = 0,
                                 .flag = (int *)0, .val = 'T'},
                                {.name = "verbose", .has_arg = 0,
                                 .flag = (int *)0, .val = 'v'},
                                {.name = "version", .has_arg = 0,
                                 .flag = (int *)0, .val = 'V'},
                                {.name = "fast", .has_arg = 0,
                                 .flag = (int *)0, .val = '1'},
                                {.name = "best", .has_arg = 0,
                                 .flag = (int *)0, .val = '9'},
                                {.name = "lzw", .has_arg = 0,
                                 .flag = (int *)0, .val = 'Z'},
                                {.name = "bits", .has_arg = 1,
                                 .flag = (int *)0, .val = 'b'},
                                {.name = (char const *)0, .has_arg = 0,
                                 .flag = (int *)0, .val = 0}};
static void usage(void);

static void help(void);

static void license(void);

static void version(void);

static void treat_stdin(void);

static void treat_file(char *iname) __attribute__((__FC_OLDSTYLEPROTO__));

static int create_outfile(void);

static int do_stat(char *name, struct stat *sbuf) __attribute__((__FC_OLDSTYLEPROTO__));

static char *get_suffix(char *name) __attribute__((__FC_OLDSTYLEPROTO__));

static int get_istat(char *iname, struct stat *sbuf) __attribute__((__FC_OLDSTYLEPROTO__));

static int make_ofname(void);

static int same_file(struct stat *stat1, struct stat *stat2) __attribute__((
__FC_OLDSTYLEPROTO__));

static int name_too_long(char *name, struct stat *statb) __attribute__((
__FC_OLDSTYLEPROTO__));

static void shorten_name(char *name) __attribute__((__FC_OLDSTYLEPROTO__));

int get_method(int in) __attribute__((__FC_OLDSTYLEPROTO__));

static void do_list(int ifd_0, int method_0) __attribute__((__FC_OLDSTYLEPROTO__));

static int check_ofname(void);

static void copy_stat(struct stat *ifstat) __attribute__((__FC_OLDSTYLEPROTO__));

static void do_exit(int exitcode) __attribute__((__FC_OLDSTYLEPROTO__));

int main(int argc, char **argv);

int (*work)(int infile, int outfile) = & zip;
static void usage(void)
{
  fprintf(stderr,"usage: %s [-%scdfhlLnN%stvV19] [-S suffix] [file ...]\n",
          progname,"","");
  return;
}

static char *help_msg[17] =   
                              {(char *)" -c --stdout      write on standard output, keep original files unchanged",
                               (char *)" -d --decompress  decompress",
                               (char *)" -f --force       force overwrite of output file and compress links",
                               (char *)" -h --help        give this help",
                               (char *)" -l --list        list compressed file contents",
                               (char *)" -L --license     display software license",
                               (char *)" -n --no-name     do not save or restore the original name and time stamp",
                               (char *)" -N --name        save or restore the original name and time stamp",
                               (char *)" -q --quiet       suppress all warnings",
                               (char *)" -S .suf  --suffix .suf     use suffix .suf on compressed files",
                               (char *)" -t --test        test compressed file integrity",
                               (char *)" -v --verbose     verbose mode",
                               (char *)" -V --version     display version number",
                               (char *)" -1 --fast        compress faster",
                               (char *)" -9 --best        compress better",
                               (char *)" file...          files to (de)compress. If none given, use standard input.",
                               (char *)0};
static void help(void)
{
  char **p;
  p = help_msg;
  fprintf(stderr,"%s %s (%s)\n",progname,"1.2.4","18 Aug 93");
  usage();
  while (1) {
    
    
    if (! *p) break;
    {
      char **tmp;
      tmp = p;
      p ++;
      fprintf(stderr,"%s\n",*tmp);
    }
  }
  return;
}

static void license(void)
{
  char **p;
  p = license_msg;
  fprintf(stderr,"%s %s (%s)\n",progname,"1.2.4","18 Aug 93");
  while (1) {
    
    
    if (! *p) break;
    {
      char **tmp;
      tmp = p;
      p ++;
      fprintf(stderr,"%s\n",*tmp);
    }
  }
  return;
}

static void version(void)
{
  fprintf(stderr,"%s %s (%s)\n",progname,"1.2.4","18 Aug 93");
  fprintf(stderr,"Compilation options:\n%s %s ","NO_DIR","NO_UTIME");
  fprintf(stderr,"NO_CHOWN ");
  fprintf(stderr,"\n");
  return;
}

/*@ assigns \nothing; */
extern int isatty(int x_0);

static void treat_stdin(void)
{
  
  
  
  
  if (! force && ! list) {
    int tmp_3;
    int tmp_2;
    struct _IO_FILE *tmp_1;
    
    
    if (decompress) tmp_1 = stdin; else tmp_1 = stdout;
    tmp_2 = fileno(tmp_1);
    tmp_3 = isatty(tmp_2);
    
    
    if (tmp_3) {
      char const *tmp;
      char const *tmp_0;
      
      
      if (decompress) tmp = "de"; else tmp = "";
      
      
      if (decompress) tmp_0 = "read from"; else tmp_0 = "written to";
      fprintf(stderr,
              "%s: compressed data not %s a terminal. Use -f to force %scompression.\n",
              progname,tmp_0,tmp);
      fprintf(stderr,"For help, type: %s -h\n",progname);
      do_exit(1);
    }
  }
  strcpy(ifname,"stdin");
  strcpy(ofname,"stdout");
  time_stamp = (long)0;
  
  
  
  
  if (list || ! no_time) {
    int tmp_5;
    int tmp_4;
    tmp_4 = fileno(stdin);
    tmp_5 = fstat(tmp_4,& istat);
    
    
    if (tmp_5 != 0) error((char *)"fstat(stdin)");
    time_stamp = istat.st_mtim.tv_sec;
  }
  ifile_size = -1L;
  clear_bufs();
  to_stdout = 1;
  part_nb = 0;
  
  
  if (decompress) {
    method = get_method(ifd);
    
    
    if (method < 0) do_exit(exit_code);
  }
  
  
  if (list) {
    do_list(ifd,method);
    goto return_label;
  }
  while (1) {
    {
      int tmp_8;
      int tmp_6;
      int tmp_7;
      tmp_6 = fileno(stdout);
      tmp_7 = fileno(stdin);
      tmp_8 = (*work)(tmp_7,tmp_6);
      
      
      if (tmp_8 != 0) goto return_label;
      
      
      
      
      
      
      if ((! decompress || last_member) || inptr == insize) break;
      method = get_method(ifd);
      
      
      if (method < 0) goto return_label;
      bytes_out = (long)0;
    }
  }
  
  
  if (verbose) {
    
    
    if (test) fprintf(stderr," OK\n");
    else {
      
      
      if (! decompress) {
        display_ratio(bytes_in - (bytes_out - header_bytes),bytes_in,stderr);
        fprintf(stderr,"\n");
      }
    }
  }
  return_label: ;
  return;
}

/*@ assigns \nothing; */
extern int close(int x_0);

/*@ assigns *x_0; */
extern int unlink(char *x_0);

static void treat_file(char *iname) __attribute__((__FC_OLDSTYLEPROTO__));;
static void treat_file(char *iname)
{
  int tmp;
  int tmp_0;
  int tmp_3;
  tmp = strcmp((char const *)iname,"-");
  
  
  if (tmp == 0) {
    int cflag;
    cflag = to_stdout;
    treat_stdin();
    to_stdout = cflag;
    goto return_label;
  }
  tmp_0 = get_istat(iname,& istat);
  
  
  if (tmp_0 != 0) goto return_label;
  

  

  if ((istat.st_mode & (unsigned int)0170000) == (unsigned int)0040000) {
    
    
    if (! quiet) fprintf(stderr,"%s: %s is a directory -- ignored\n",
                         progname,ifname);
    
    
    if (exit_code == 0) exit_code = 2;
    goto return_label;
  }
  

  

  if (! ((istat.st_mode & (unsigned int)0170000) == (unsigned int)0100000)) {
    
    
    if (! quiet) fprintf(stderr,
                         "%s: %s is not a directory or a regular file - ignored\n",
                         progname,ifname);
    
    
    if (exit_code == 0) exit_code = 2;
    goto return_label;
  }
  
  
  
  
  
  
  if ((istat.st_nlink > (unsigned long)1 && ! to_stdout) && ! force) {
    
    
    if (! quiet) {
      int tmp_1;
      
      
      if (istat.st_nlink > (unsigned long)2) tmp_1 = 's'; else tmp_1 = ' ';
      fprintf(stderr,"%s: %s has %d other link%c -- unchanged\n",progname,
              ifname,(int)istat.st_nlink - 1,tmp_1);
    }
    
    
    if (exit_code == 0) exit_code = 2;
    goto return_label;
  }
  ifile_size = istat.st_size;
  
  
  
  
  if (no_time && ! list) time_stamp = (long)0;
  else time_stamp = istat.st_mtim.tv_sec;
  
  
  
  
  
  
  if ((to_stdout && ! list) && ! test) strcpy(ofname,"stdout");
  else {
    int tmp_2;
    tmp_2 = make_ofname();
    
    
    if (tmp_2 != 0) goto return_label;
  }
  
  
  
  
  if (ascii && ! decompress) tmp_3 = 00; else tmp_3 = 00 | 0;
  ifd = open((char const *)(ifname),tmp_3,0400 | 0200);
  
  
  if (ifd == -1) {
    fprintf(stderr,"%s: ",progname);
    perror((char const *)(ifname));
    exit_code = 1;
    goto return_label;
  }
  clear_bufs();
  part_nb = 0;
  
  
  if (decompress) {
    method = get_method(ifd);
    
    
    if (method < 0) {
      close(ifd);
      goto return_label;
    }
  }
  
  
  if (list) {
    do_list(ifd,method);
    close(ifd);
    goto return_label;
  }
  
  
  if (to_stdout) ofd = fileno(stdout);
  else {
    int tmp_4;
    tmp_4 = create_outfile();
    
    
    if (tmp_4 != 0) goto return_label;
    
    
    
    
    
    
    
    
    if (((! decompress && save_orig_name) && ! verbose) && ! quiet) fprintf
                                                                    (stderr,
                                                                    "%s: %s compressed to %s\n",
                                                                    progname,
                                                                    ifname,
                                                                    ofname);
  }
  
  
  if (! save_orig_name) save_orig_name = ! no_name;
  
  
  if (verbose) {
    char const *tmp_8;
    size_t tmp_5;
    tmp_5 = strlen((char const *)(ifname));
    
    
    if ((int)tmp_5 >= 15) tmp_8 = "";
    else {
      char const *tmp_7;
      size_t tmp_6;
      tmp_6 = strlen((char const *)(ifname));
      
      
      if ((int)tmp_6 >= 7) tmp_7 = "\t"; else tmp_7 = "\t\t";
      tmp_8 = tmp_7;
    }
    fprintf(stderr,"%s:\t%s",ifname,tmp_8);
  }
  while (1) {
    {
      int tmp_9;
      tmp_9 = (*work)(ifd,ofd);
      
      
      if (tmp_9 != 0) {
        method = -1;
        break;
      }
      
      
      
      
      
      
      if ((! decompress || last_member) || inptr == insize) break;
      method = get_method(ifd);
      
      
      if (method < 0) break;
      bytes_out = (long)0;
    }
  }
  close(ifd);
  
  
  if (! to_stdout) {
    int tmp_10;
    tmp_10 = close(ofd);
    
    
    if (tmp_10) write_error();
  }
  
  
  if (method == -1) {
    
    
    if (! to_stdout) unlink(ofname);
    goto return_label;
  }
  
  
  if (verbose) {
    
    
    if (test) fprintf(stderr," OK");
    else {
      
      
      if (decompress) display_ratio(bytes_out - (bytes_in - header_bytes),
                                    bytes_out,stderr);
      else display_ratio(bytes_in - (bytes_out - header_bytes),bytes_in,
                         stderr);
    }
    
    
    
    
    if (! test && ! to_stdout) fprintf(stderr," -- replaced with %s",ofname);
    fprintf(stderr,"\n");
  }
  
  
  if (! to_stdout) copy_stat(& istat);
  return_label: ;
  return;
}

static int create_outfile(void)
{
  int __retres;
  struct stat ostat;
  int flags_0;
  flags_0 = ((01 | 0100) | 0200) | 0;
  
  
  
  
  if (ascii && decompress) flags_0 &= ~ 0;
  while (1) {
    {
      int tmp;
      int tmp_0;
      int tmp_1;
      tmp = check_ofname();
      
      
      if (tmp != 0) {
        close(ifd);
        __retres = 1;
        goto return_label;
      }
      remove_ofname = 1;
      ofd = open((char const *)(ofname),flags_0,0400 | 0200);
      
      
      if (ofd == -1) {
        perror((char const *)(ofname));
        close(ifd);
        exit_code = 1;
        __retres = 1;
        goto return_label;
      }
      tmp_0 = fstat(ofd,& ostat);
      
      
      if (tmp_0 != 0) {
        fprintf(stderr,"%s: ",progname);
        perror((char const *)(ofname));
        close(ifd);
        close(ofd);
        unlink(ofname);
        exit_code = 1;
        __retres = 1;
        goto return_label;
      }
      tmp_1 = name_too_long(ofname,& ostat);
      
      
      if (! tmp_1) {
        __retres = 0;
        goto return_label;
      }
      
      
      if (decompress) {
        
        
        if (! quiet) fprintf(stderr,"%s: %s: warning, name truncated\n",
                             progname,ofname);
        
        
        if (exit_code == 0) exit_code = 2;
        __retres = 0;
        goto return_label;
      }
      close(ofd);
      unlink(ofname);
      shorten_name(ofname);
    }
  }
  return_label: ;
  return __retres;
}

static int do_stat(char *name, struct stat *sbuf) __attribute__((__FC_OLDSTYLEPROTO__));;
static int do_stat(char *name, struct stat *sbuf)
{
  int __retres;
  int *tmp;
  int tmp_1;
  tmp = __errno_location();
  *tmp = 0;
  
  
  
  
  if (! to_stdout && ! force) {
    int tmp_0;
    tmp_0 = lstat((char const *)name,sbuf);
    __retres = tmp_0;
    goto return_label;
  }
  tmp_1 = stat((char const *)name,sbuf);
  __retres = tmp_1;
  return_label: ;
  return __retres;
}

static char *known_suffixes[9] =   
                                   {z_suffix, (char *)".gz", (char *)".z",
                                    (char *)".taz", (char *)".tgz",
                                    (char *)"-gz", (char *)"-z",
                                    (char *)"_z", (char *)((void *)0)};
static char *get_suffix(char *name) __attribute__((__FC_OLDSTYLEPROTO__));;
static char *get_suffix(char *name)
{
  char *__retres;
  int nlen;
  int slen;
  char suffix[30 + 3];
  char **suf;
  int tmp;
  size_t tmp_0;
  size_t tmp_1;
  suf = known_suffixes;
  tmp = strcmp((char const *)(z_suffix),"z");
  
  
  if (tmp == 0) suf ++;
  tmp_0 = strlen((char const *)name);
  nlen = (int)tmp_0;
  
  
  if (nlen <= 30 + 2) strcpy(suffix,(char const *)name);
  else strcpy(suffix,(char const *)(((name + nlen) - 30) - 2));
  strlwr(suffix);
  tmp_1 = strlen((char const *)(suffix));
  slen = (int)tmp_1;
  while (1) {
    {
      int s;
      size_t tmp_2;
      tmp_2 = strlen((char const *)*suf);
      s = (int)tmp_2;
      
      
      
      
      if (slen > s && (int)suffix[(slen - s) - 1] != '/') {
        int tmp_3;
        tmp_3 = strcmp((char const *)(& suffix[slen] - s),(char const *)*suf);
        
        
        if (tmp_3 == 0) {
          __retres = (name + nlen) - s;
          goto return_label;
        }
      }
    }
    suf ++;
    
    
    if (! (*suf != (void *)0)) break;
  }
  __retres = (char *)((void *)0);
  return_label: ;
  return __retres;
}

static char *suffixes[6] = {z_suffix, (char *)".gz", (char *)".z",
                            (char *)"-z", (char *)".Z", (char *)((void *)0)};
static int get_istat(char *iname, struct stat *sbuf) __attribute__((__FC_OLDSTYLEPROTO__));;
static int get_istat(char *iname, struct stat *sbuf)
{
  int __retres;
  int ilen;
  char **suf;
  char *s;
  int tmp;
  size_t tmp_1;
  int tmp_2;
  suf = suffixes;
  strcpy(ifname,(char const *)iname);
  tmp = do_stat(ifname,sbuf);
  
  
  if (tmp == 0) {
    __retres = 0;
    goto return_label;
  }
  
  
  if (! decompress) goto _LOR;
  else {
    int *tmp_0;
    tmp_0 = __errno_location();
    
    
    if (*tmp_0 != 2) {
      _LOR: perror((char const *)(ifname));
      exit_code = 1;
      __retres = 1;
      goto return_label;
    }
  }
  s = get_suffix(ifname);
  
  
  if (s != (void *)0) {
    perror((char const *)(ifname));
    exit_code = 1;
    __retres = 1;
    goto return_label;
  }
  tmp_1 = strlen((char const *)(ifname));
  ilen = (int)tmp_1;
  tmp_2 = strcmp((char const *)(z_suffix),".gz");
  
  
  if (tmp_2 == 0) suf ++;
  while (1) {
    {
      int tmp_3;
      s = *suf;
      strcat(ifname,(char const *)s);
      tmp_3 = do_stat(ifname,sbuf);
      
      
      if (tmp_3 == 0) {
        __retres = 0;
        goto return_label;
      }
      ifname[ilen] = (char)'\000';
    }
    suf ++;
    
    
    if (! (*suf != (void *)0)) break;
  }
  strcat(ifname,(char const *)(z_suffix));
  perror((char const *)(ifname));
  exit_code = 1;
  __retres = 1;
  return_label: ;
  return __retres;
}

static int make_ofname(void)
{
  int __retres;
  char *suff;
  strcpy(ofname,(char const *)(ifname));
  suff = get_suffix(ofname);
  
  
  if (decompress) {
    int tmp;
    
    
    if (suff == (void *)0) {
      
      
      
      
      
      
      if (! recursive && (list || test)) {
        __retres = 0;
        goto return_label;
      }
      
      
      
      
      
      
      if (verbose || (! recursive && ! quiet)) {
        
        
        if (! quiet) fprintf(stderr,"%s: %s: unknown suffix -- ignored\n",
                             progname,ifname);
        
        
        if (exit_code == 0) exit_code = 2;
      }
      __retres = 2;
      goto return_label;
    }
    strlwr(suff);
    tmp = strcmp((char const *)suff,".tgz");
    
    
    if (tmp == 0) goto _LOR;
    else {
      int tmp_0;
      tmp_0 = strcmp((char const *)suff,".taz");
      
      
      if (tmp_0 == 0) _LOR: strcpy(suff,".tar"); else *suff = (char)'\000';
    }
  }
  else {
    
    
    if (suff != (void *)0) {
      
      
      
      
      
      
      if (verbose || (! recursive && ! quiet)) fprintf(stderr,
                                                       "%s: %s already has %s suffix -- unchanged\n",
                                                       progname,ifname,suff);
      
      
      if (exit_code == 0) exit_code = 2;
      __retres = 2;
      goto return_label;
    }
    else {
      save_orig_name = 0;
      strcat(ofname,(char const *)(z_suffix));
    }
  }
  __retres = 0;
  return_label: ;
  return __retres;
}

int get_method(int in) __attribute__((__FC_OLDSTYLEPROTO__));;
int get_method(int in)
{
  int __retres;
  uch flags_0;
  char magic[2];
  ulg stamp;
  int tmp_61;
  
  
  
  
  if (force && to_stdout) {
    int tmp_1;
    int tmp_4;
    
    
    if (inptr < insize) {
      unsigned int tmp;
      tmp = inptr;
      inptr ++;
      tmp_1 = (int)inbuf[tmp];
    }
    else tmp_1 = fill_inbuf(1);
    magic[0] = (char)tmp_1;
    
    
    if (inptr < insize) {
      unsigned int tmp_2;
      tmp_2 = inptr;
      inptr ++;
      tmp_4 = (int)inbuf[tmp_2];
    }
    else tmp_4 = fill_inbuf(1);
    magic[1] = (char)tmp_4;
  }
  else {
    int tmp_7;
    int tmp_10;
    
    
    if (inptr < insize) {
      unsigned int tmp_5;
      tmp_5 = inptr;
      inptr ++;
      tmp_7 = (int)inbuf[tmp_5];
    }
    else tmp_7 = fill_inbuf(0);
    magic[0] = (char)tmp_7;
    
    
    if (inptr < insize) {
      unsigned int tmp_8;
      tmp_8 = inptr;
      inptr ++;
      tmp_10 = (int)inbuf[tmp_8];
    }
    else tmp_10 = fill_inbuf(0);
    magic[1] = (char)tmp_10;
  }
  method = -1;
  part_nb ++;
  header_bytes = (long)0;
  last_member = 0;
  tmp_61 = memcmp((void const *)(magic),(void const *)"\037\213",
                  (unsigned long)2);
  
  
  if (tmp_61 == 0) goto _LOR;
  else {
    int tmp_62;
    tmp_62 = memcmp((void const *)(magic),(void const *)"\037\236",
                    (unsigned long)2);
    
    
    if (tmp_62 == 0) {
      _LOR:
        {
          int tmp_13;
          int tmp_16;
          int tmp_19;
          int tmp_22;
          int tmp_25;
          int tmp_28;
          
          
          if (inptr < insize) {
            unsigned int tmp_11;
            tmp_11 = inptr;
            inptr ++;
            tmp_13 = (int)inbuf[tmp_11];
          }
          else tmp_13 = fill_inbuf(0);
          method = tmp_13;
          
          
          if (method != 8) {
            fprintf(stderr,
                    "%s: %s: unknown method %d -- get newer version of gzip\n",
                    progname,ifname,method);
            exit_code = 1;
            __retres = -1;
            goto return_label;
          }
          work = & unzip;
          
          
          if (inptr < insize) {
            unsigned int tmp_14;
            tmp_14 = inptr;
            inptr ++;
            tmp_16 = (int)inbuf[tmp_14];
          }
          else tmp_16 = fill_inbuf(0);
          flags_0 = (unsigned char)tmp_16;
          
          
          if (((int)flags_0 & 0x20) != 0) {
            fprintf(stderr,
                    "%s: %s is encrypted -- get newer version of gzip\n",
                    progname,ifname);
            exit_code = 1;
            __retres = -1;
            goto return_label;
          }
          
          
          if (((int)flags_0 & 0x02) != 0) {
            fprintf(stderr,
                    "%s: %s is a a multi-part gzip file -- get newer version of gzip\n",
                    progname,ifname);
            exit_code = 1;
            
            
            if (force <= 1) {
              __retres = -1;
              goto return_label;
            }
          }
          
          
          if (((int)flags_0 & 0xC0) != 0) {
            fprintf(stderr,
                    "%s: %s has flags 0x%x -- get newer version of gzip\n",
                    progname,ifname,(int)flags_0);
            exit_code = 1;
            
            
            if (force <= 1) {
              __retres = -1;
              goto return_label;
            }
          }
          
          
          if (inptr < insize) {
            unsigned int tmp_17;
            tmp_17 = inptr;
            inptr ++;
            tmp_19 = (int)inbuf[tmp_17];
          }
          else tmp_19 = fill_inbuf(0);
          stamp = (unsigned long)tmp_19;
          
          
          if (inptr < insize) {
            unsigned int tmp_20;
            tmp_20 = inptr;
            inptr ++;
            tmp_22 = (int)inbuf[tmp_20];
          }
          else tmp_22 = fill_inbuf(0);
          stamp |= (unsigned long)tmp_22 << 8;
          
          
          if (inptr < insize) {
            unsigned int tmp_23;
            tmp_23 = inptr;
            inptr ++;
            tmp_25 = (int)inbuf[tmp_23];
          }
          else tmp_25 = fill_inbuf(0);
          stamp |= (unsigned long)tmp_25 << 16;
          
          
          if (inptr < insize) {
            unsigned int tmp_26;
            tmp_26 = inptr;
            inptr ++;
            tmp_28 = (int)inbuf[tmp_26];
          }
          else tmp_28 = fill_inbuf(0);
          stamp |= (unsigned long)tmp_28 << 24;
          
          
          
          
          if (stamp != (unsigned long)0 && ! no_time) time_stamp = (long)stamp;
          
          
          if (inptr < insize) {
            unsigned int tmp_29;
            tmp_29 = inptr;
            inptr ++;
          }
          else fill_inbuf(0);
          
          
          if (inptr < insize) {
            unsigned int tmp_30;
            tmp_30 = inptr;
            inptr ++;
          }
          else fill_inbuf(0);
          
          
          if (((int)flags_0 & 0x02) != 0) {
            unsigned int part;
            int tmp_33;
            int tmp_36;
            
            
            if (inptr < insize) {
              unsigned int tmp_31;
              tmp_31 = inptr;
              inptr ++;
              tmp_33 = (int)inbuf[tmp_31];
            }
            else tmp_33 = fill_inbuf(0);
            part = (unsigned int)tmp_33;
            
            
            if (inptr < insize) {
              unsigned int tmp_34;
              tmp_34 = inptr;
              inptr ++;
              tmp_36 = (int)inbuf[tmp_34];
            }
            else tmp_36 = fill_inbuf(0);
            part |= (unsigned int)tmp_36 << 8;
            
            
            if (verbose) fprintf(stderr,"%s: %s: part number %u\n",progname,
                                 ifname,part);
          }
          
          
          if (((int)flags_0 & 0x04) != 0) {
            unsigned int len;
            int tmp_39;
            int tmp_42;
            
            
            if (inptr < insize) {
              unsigned int tmp_37;
              tmp_37 = inptr;
              inptr ++;
              tmp_39 = (int)inbuf[tmp_37];
            }
            else tmp_39 = fill_inbuf(0);
            len = (unsigned int)tmp_39;
            
            
            if (inptr < insize) {
              unsigned int tmp_40;
              tmp_40 = inptr;
              inptr ++;
              tmp_42 = (int)inbuf[tmp_40];
            }
            else tmp_42 = fill_inbuf(0);
            len |= (unsigned int)tmp_42 << 8;
            
            
            if (verbose) fprintf(stderr,
                                 "%s: %s: extra field of %u bytes ignored\n",
                                 progname,ifname,len);
            while (1) {
              {
                unsigned int tmp_44;
                tmp_44 = len;
                len --;
                
                
                if (! tmp_44) break;
                
                
                if (inptr < insize) {
                  unsigned int tmp_43;
                  tmp_43 = inptr;
                  inptr ++;
                }
                else fill_inbuf(0);
              }
            }
          }
          
          
          if (((int)flags_0 & 0x08) != 0) {
            
            
            
            
            
            
            
            
            if ((no_name || (to_stdout && ! list)) || part_nb > 1) {
              char c;
              while (1) {
                
                
                if (inptr < insize) {
                  unsigned int tmp_45;
                  tmp_45 = inptr;
                  inptr ++;
                  c = (char)inbuf[tmp_45];
                }
                else {
                  int tmp_46;
                  tmp_46 = fill_inbuf(0);
                  c = (char)tmp_46;
                }
                
                
                if (! ((int)c != 0)) break;
              }
            }
            else {
              char *p;
              char *base;
              p = gzipbasename(ofname);
              base = p;
              while (1) {
                {
                  int tmp_50;
                  char *tmp_51;
                  
                  
                  if (inptr < insize) {
                    unsigned int tmp_48;
                    tmp_48 = inptr;
                    inptr ++;
                    tmp_50 = (int)inbuf[tmp_48];
                  }
                  else tmp_50 = fill_inbuf(0);
                  *p = (char)tmp_50;
                  tmp_51 = p;
                  p ++;
                  
                  
                  if ((int)*tmp_51 == '\000') break;
                  
                  
                  if (p >= & ofname[sizeof(ofname)]) error((char *)"corrupted input -- file name too large");
                }
              }
              
              
              if (! list) {
                
                
                if (base) list = 0;
              }
            }
          }
          
          
          if (((int)flags_0 & 0x10) != 0) 
            while (1) {
              {
                int tmp_54;
                
                
                if (inptr < insize) {
                  unsigned int tmp_52;
                  tmp_52 = inptr;
                  inptr ++;
                  tmp_54 = (int)inbuf[tmp_52];
                }
                else tmp_54 = fill_inbuf(0);
                
                
                if (! (tmp_54 != 0)) break;
              }
            }
          
          
          if (part_nb == 1) header_bytes = (long)(inptr + (unsigned int)2 * sizeof(long));
        }
    }
    else {
      int tmp_59;
      tmp_59 = memcmp((void const *)(magic),(void const *)"PK\003\004",
                      (unsigned long)2);
      
      
      if (tmp_59 == 0) {
        
        
        if (inptr == (unsigned int)2) {
          int tmp_60;
          char *tmp_63;
          tmp_63 = convert_uint8s_sint8s(inbuf);
          tmp_60 = memcmp((void const *)tmp_63,(void const *)"PK\003\004",
                          (unsigned long)4);
          
          
          if (tmp_60 == 0) {
            int tmp_55;
            inptr = (unsigned int)0;
            work = & unzip;
            tmp_55 = check_zipfile(in);
            
            
            if (tmp_55 != 0) {
              __retres = -1;
              goto return_label;
            }
            last_member = 1;
          }
          else goto _LAND_0;
        }
        else goto _LAND_0;
      }
      else {
        int tmp_58;
        _LAND_0:
          tmp_58 = memcmp((void const *)(magic),(void const *)"\037\036",
                          (unsigned long)2);
        
        
        if (tmp_58 == 0) {
          work = & unpack;
          method = 2;
        }
        else {
          int tmp_57;
          tmp_57 = memcmp((void const *)(magic),(void const *)"\037\235",
                          (unsigned long)2);
          
          
          if (tmp_57 == 0) {
            work = & unlzw;
            method = 1;
            last_member = 1;
          }
          else {
            int tmp_56;
            tmp_56 = memcmp((void const *)(magic),(void const *)"\037\240",
                            (unsigned long)2);
            
            
            if (tmp_56 == 0) {
              work = & unlzh;
              method = 3;
              last_member = 1;
            }
            else {
              
              
              
              
              
              
              if ((force && to_stdout) && ! list) {
                method = 0;
                work = & copy;
                inptr = (unsigned int)0;
                last_member = 1;
              }
            }
          }
        }
      }
    }
  }
  
  
  if (method >= 0) {
    __retres = method;
    goto return_label;
  }
  
  
  if (part_nb == 1) {
    fprintf(stderr,"\n%s: %s: not in gzip format\n",progname,ifname);
    exit_code = 1;
    __retres = -1;
    goto return_label;
  }
  else {
    
    
    if (! quiet) fprintf(stderr,
                         "\n%s: %s: decompression OK, trailing garbage ignored\n",
                         progname,ifname);
    
    
    if (exit_code == 0) exit_code = 2;
    __retres = -2;
    goto return_label;
  }
  return_label: ;
  return __retres;
}

static int first_time = 1;
static char *methods[9] =   
                            {(char *)"store", (char *)"compr",
                             (char *)"pack ", (char *)"lzh  ", (char *)"",
                             (char *)"", (char *)"", (char *)"",
                             (char *)"defla"};
/*@ assigns \nothing; */
extern int lseek(int x_0, long x_1, int x_2);

static void do_list(int ifd_0, int method_0) __attribute__((__FC_OLDSTYLEPROTO__));;
static void do_list(int ifd_0, int method_0)
{
  ulg crc_1;
  char *date;
  char *tmp_1;
  
  
  
  
  if (first_time && method_0 >= 0) {
    first_time = 0;
    
    
    if (verbose) printf("method  crc     date  time  ");
    
    
    if (! quiet) printf("compressed  uncompr. ratio uncompressed_name\n");
  }
  else {
    
    
    if (method_0 < 0) {
      
      
      
      
      if (total_in <= (long)0 || total_out <= (long)0) goto return_label;
      
      
      if (verbose) printf("                            %9lu %9lu ",total_in,
                          total_out);
      else {
        
        
        if (! quiet) printf("%9ld %9ld ",total_in,total_out);
      }
      display_ratio(total_out - (total_in - header_bytes),total_out,stdout);
      printf(" (totals)\n");
      goto return_label;
    }
  }
  crc_1 = (unsigned long)(~ 0);
  bytes_out = -1L;
  bytes_in = ifile_size;
  
  
  
  
  if (method_0 == 8 && ! last_member) {
    bytes_in = (long)lseek(ifd_0,(long)(-8),2);
    
    
    if (bytes_in != -1L) {
      uch buf[8];
      int tmp_0;
      bytes_in += 8L;
      tmp_0 = spec_read(ifd_0,buf,(int)sizeof(buf));
      
      
      if ((unsigned int)tmp_0 != sizeof(buf)) read_error();
      crc_1 = (unsigned long)((int)((unsigned short)buf[0]) | ((int)((unsigned short)buf[1]) << 8)) | (
              (unsigned long)((int)((unsigned short)*(& buf[2] + 0)) | (
                              (int)((unsigned short)*(& buf[2] + 1)) << 8)) << 16);
      bytes_out = (long)((unsigned long)((int)((unsigned short)*(& buf[4] + 0)) | (
                                         (int)((unsigned short)*(& buf[4] + 1)) << 8)) | (
                         (unsigned long)((int)((unsigned short)*((& buf[4] + 2) + 0)) | (
                                         (int)((unsigned short)*((& buf[4] + 2) + 1)) << 8)) << 16));
    }
  }
  tmp_1 = ctime((time_t const *)(& time_stamp));
  date = tmp_1 + 4;
  *(date + 12) = (char)'\000';
  
  
  if (verbose) printf("%5s %08lx %11s ",methods[method_0],crc_1,date);
  printf("%9ld %9ld ",bytes_in,bytes_out);
  
  
  if (bytes_in == -1L) {
    total_in = -1L;
    header_bytes = (long)0;
    bytes_out = header_bytes;
    bytes_in = bytes_out;
  }
  else {
    
    
    if (total_in >= (long)0) total_in += bytes_in;
  }
  
  
  if (bytes_out == -1L) {
    total_out = -1L;
    header_bytes = (long)0;
    bytes_out = header_bytes;
    bytes_in = bytes_out;
  }
  else {
    
    
    if (total_out >= (long)0) total_out += bytes_out;
  }
  display_ratio(bytes_out - (bytes_in - header_bytes),bytes_out,stdout);
  printf(" %s\n",ofname);
  return_label: ;
  return;
}

static int same_file(struct stat *stat1, struct stat *stat2) __attribute__((
__FC_OLDSTYLEPROTO__));;
static int same_file(struct stat *stat1, struct stat *stat2)
{
  int __retres;
  __retres = ((stat1->st_ino == stat2->st_ino && stat1->st_dev == stat2->st_dev) != 0) != 0;
  return __retres;
}

static int name_too_long(char *name, struct stat *statb) __attribute__((
__FC_OLDSTYLEPROTO__));;
static int name_too_long(char *name, struct stat *statb)
{
  int s;
  size_t tmp;
  char c;
  struct stat tstat;
  int res;
  int tmp_2;
  int tmp_0;
  tmp = strlen((char const *)name);
  s = (int)tmp;
  c = *(name + (s - 1));
  tstat = *statb;
  *(name + (s - 1)) = (char)'\000';
  tmp_0 = stat((char const *)name,& tstat);
  
  
  if (tmp_0 == 0) {
    int tmp_1;
    tmp_1 = same_file(statb,& tstat);
    
    
    if (tmp_1) tmp_2 = 1; else tmp_2 = 0;
  }
  else tmp_2 = 0;
  res = tmp_2;
  *(name + (s - 1)) = c;
  return res;
}

static void shorten_name(char *name) __attribute__((__FC_OLDSTYLEPROTO__));;
static void shorten_name(char *name)
{
  int len;
  char *trunc;
  int plen;
  int min_part;
  char *p;
  size_t tmp;
  trunc = (char *)((void *)0);
  min_part = 3;
  tmp = strlen((char const *)name);
  len = (int)tmp;
  
  
  if (decompress) {
    
    
    if (len <= 1) error((char *)"name too short");
    *(name + (len - 1)) = (char)'\000';
    goto return_label;
  }
  p = get_suffix(name);
  
  
  if (p == (void *)0) error((char *)"can\'t recover suffix\n");
  *p = (char)'\000';
  save_orig_name = 1;
  
  
  if (len > 4) {
    int tmp_0;
    tmp_0 = strcmp((char const *)(p - 4),".tar");
    
    
    if (tmp_0 == 0) {
      strcpy(p - 4,".tgz");
      goto return_label;
    }
  }
  while (1) {
    p = strrchr((char const *)name,'/');
    
    
    if (p) p ++; else p = name;
    while (1) {
      
      
      if (! *p) break;
      {
        size_t tmp_1;
        tmp_1 = strcspn((char const *)p,".");
        plen = (int)tmp_1;
        p += plen;
        
        
        if (plen > min_part) trunc = p - 1;
        
        
        if (*p) p ++;
      }
    }
    
    
    if (trunc == (void *)0) {
      min_part --;
      
      
      if (! (min_part != 0)) break;
    }
    else break;
  }
  
  
  if (trunc != (void *)0) {
    while (1) {
      {
        char *tmp_2;
        *(trunc + 0) = *(trunc + 1);
        tmp_2 = trunc;
        trunc ++;
        
        
        if (! *tmp_2) break;
      }
    }
    trunc --;
  }
  else {
    trunc = strrchr((char const *)name,(int)*("." + 0));
    
    
    if (trunc == (void *)0) error((char *)"internal error in shorten_name");
    
    
    if ((int)*(trunc + 1) == '\000') trunc --;
  }
  strcpy(trunc,(char const *)(z_suffix));
  return_label: ;
  return;
}

static int check_ofname(void)
{
  int __retres;
  struct stat ostat;
  int *tmp;
  int tmp_6;
  int tmp_11;
  tmp = __errno_location();
  *tmp = 0;
  while (1) {
    {
      int tmp_1;
      tmp_1 = stat((char const *)(ofname),& ostat);
      
      
      if (! (tmp_1 != 0)) break;
      {
        int *tmp_0;
        tmp_0 = __errno_location();
        
        
        if (*tmp_0 != 36) {
          __retres = 0;
          goto return_label;
        }
        shorten_name(ofname);
      }
    }
  }
  
  
  if (! decompress) {
    int tmp_3;
    tmp_3 = name_too_long(ofname,& ostat);
    
    
    if (tmp_3) {
      int tmp_2;
      shorten_name(ofname);
      tmp_2 = stat((char const *)(ofname),& ostat);
      
      
      if (tmp_2 != 0) {
        __retres = 0;
        goto return_label;
      }
    }
  }
  tmp_6 = same_file(& istat,& ostat);
  
  
  if (tmp_6) {
    int tmp_5;
    tmp_5 = strcmp((char const *)(ifname),(char const *)(ofname));
    
    
    if (tmp_5 == 0) {
      char const *tmp_4;
      
      
      if (decompress) tmp_4 = "de"; else tmp_4 = "";
      fprintf(stderr,"%s: %s: cannot %scompress onto itself\n",progname,
              ifname,tmp_4);
    }
    else fprintf(stderr,"%s: %s and %s are the same file\n",progname,ifname,
                 ofname);
    exit_code = 1;
    __retres = 1;
    goto return_label;
  }
  
  
  if (! force) {
    char response[80];
    int tmp_10;
    unsigned short const **tmp_9;
    strcpy(response,"n");
    fprintf(stderr,"%s: %s already exists;",progname,ofname);
    
    
    if (foreground) {
      int tmp_8;
      int tmp_7;
      tmp_7 = fileno(stdin);
      tmp_8 = isatty(tmp_7);
      
      
      if (tmp_8) {
        fprintf(stderr," do you wish to overwrite (y or n)? ");
        fflush(stderr);
        fgets(response,(int)(sizeof(response) - (unsigned int)1),stdin);
      }
    }
    tmp_9 = __ctype_b_loc();
    

    

    if ((int)*(*tmp_9 + (int)response[0]) & (int)((unsigned short)_ISupper)) 
      tmp_10 = ((int)response[0] - 'A') + 'a';
    else tmp_10 = (int)response[0];
    
    
    if (tmp_10 != 'y') {
      fprintf(stderr,"\tnot overwritten\n");
      
      
      if (exit_code == 0) exit_code = 2;
      __retres = 1;
      goto return_label;
    }
  }
  chmod((char const *)(ofname),(unsigned int)0777);
  tmp_11 = unlink(ofname);
  
  
  if (tmp_11) {
    fprintf(stderr,"%s: ",progname);
    perror((char const *)(ofname));
    exit_code = 1;
    __retres = 1;
    goto return_label;
  }
  __retres = 0;
  return_label: ;
  return __retres;
}

static void copy_stat(struct stat *ifstat) __attribute__((__FC_OLDSTYLEPROTO__));;
static void copy_stat(struct stat *ifstat)
{
  int tmp;
  int tmp_0;
  tmp = chmod((char const *)(ofname),ifstat->st_mode & (unsigned int)07777);
  
  
  if (tmp) {
    
    
    if (! quiet) fprintf(stderr,"%s: ",progname);
    
    
    if (exit_code == 0) exit_code = 2;
    
    
    if (! quiet) perror((char const *)(ofname));
  }
  remove_ofname = 0;
  chmod((char const *)(ifname),(unsigned int)0777);
  tmp_0 = unlink(ifname);
  
  
  if (tmp_0) {
    
    
    if (! quiet) fprintf(stderr,"%s: ",progname);
    
    
    if (exit_code == 0) exit_code = 2;
    
    
    if (! quiet) perror((char const *)(ifname));
  }
  return;
}

static int in_exit = 0;
static void do_exit(int exitcode) __attribute__((__FC_OLDSTYLEPROTO__));;
static void do_exit(int exitcode)
{
  
  
  if (in_exit) exit(exitcode);
  in_exit = 1;
  
  
  if (env != (void *)0) {
    free((void *)env);
    env = (char *)((void *)0);
  }
  
  
  if (args != (void *)0) {
    char *tmp;
    tmp = convert_charss_sint8s(args);
    free((void *)tmp);
    args = (char **)0;
  }
  exit(exitcode);
  return;
}

void abort_gzip(void)
{
  
  
  if (remove_ofname) {
    close(ofd);
    unlink(ofname);
  }
  do_exit(1);
  return;
}

__inline static unsigned int __bswap_65(unsigned int __bsx)
{
  unsigned int __retres;
  int tmp;
  tmp = __builtin_bswap32((int)__bsx);
  __retres = (unsigned int)tmp;
  return __retres;
}

__inline static __uint64_t __bswap_66(__uint64_t __bsx)
{
  __uint64_t __retres;
  int tmp;
  tmp = __builtin_bswap64((int)__bsx);
  __retres = (unsigned long)tmp;
  return __retres;
}

/*@ assigns \nothing; */
extern  __attribute__((__nothrow__)) void *malloc(size_t __size) __attribute__((
__malloc__, __leaf__));

void flush_window(void);

int inflate(void);

int huft_build(unsigned int *b, unsigned int n, unsigned int s, ush *d,
               ush *e, struct huft **t, int *m) __attribute__((__FC_OLDSTYLEPROTO__));

int huft_free(struct huft *t) __attribute__((__FC_OLDSTYLEPROTO__));

int inflate_codes(struct huft *tl, struct huft *td, int bl, int bd) __attribute__((
__FC_OLDSTYLEPROTO__));

int inflate_stored(void);

int inflate_fixed(void);

int inflate_dynamic(void);

int inflate_block(int *e) __attribute__((__FC_OLDSTYLEPROTO__));

static unsigned int border[19] =   
                                   {(unsigned int)16, (unsigned int)17,
                                    (unsigned int)18, (unsigned int)0,
                                    (unsigned int)8, (unsigned int)7,
                                    (unsigned int)9, (unsigned int)6,
                                    (unsigned int)10, (unsigned int)5,
                                    (unsigned int)11, (unsigned int)4,
                                    (unsigned int)12, (unsigned int)3,
                                    (unsigned int)13, (unsigned int)2,
                                    (unsigned int)14, (unsigned int)1,
                                    (unsigned int)15};
static ush cplens[31] =   
                          {(unsigned short)3, (unsigned short)4,
                           (unsigned short)5, (unsigned short)6,
                           (unsigned short)7, (unsigned short)8,
                           (unsigned short)9, (unsigned short)10,
                           (unsigned short)11, (unsigned short)13,
                           (unsigned short)15, (unsigned short)17,
                           (unsigned short)19, (unsigned short)23,
                           (unsigned short)27, (unsigned short)31,
                           (unsigned short)35, (unsigned short)43,
                           (unsigned short)51, (unsigned short)59,
                           (unsigned short)67, (unsigned short)83,
                           (unsigned short)99, (unsigned short)115,
                           (unsigned short)131, (unsigned short)163,
                           (unsigned short)195, (unsigned short)227,
                           (unsigned short)258, (unsigned short)0,
                           (unsigned short)0};
static ush cplext[31] =   
                          {(unsigned short)0, (unsigned short)0,
                           (unsigned short)0, (unsigned short)0,
                           (unsigned short)0, (unsigned short)0,
                           (unsigned short)0, (unsigned short)0,
                           (unsigned short)1, (unsigned short)1,
                           (unsigned short)1, (unsigned short)1,
                           (unsigned short)2, (unsigned short)2,
                           (unsigned short)2, (unsigned short)2,
                           (unsigned short)3, (unsigned short)3,
                           (unsigned short)3, (unsigned short)3,
                           (unsigned short)4, (unsigned short)4,
                           (unsigned short)4, (unsigned short)4,
                           (unsigned short)5, (unsigned short)5,
                           (unsigned short)5, (unsigned short)5,
                           (unsigned short)0, (unsigned short)99,
                           (unsigned short)99};
static ush cpdist[30] =   
                          {(unsigned short)1, (unsigned short)2,
                           (unsigned short)3, (unsigned short)4,
                           (unsigned short)5, (unsigned short)7,
                           (unsigned short)9, (unsigned short)13,
                           (unsigned short)17, (unsigned short)25,
                           (unsigned short)33, (unsigned short)49,
                           (unsigned short)65, (unsigned short)97,
                           (unsigned short)129, (unsigned short)193,
                           (unsigned short)257, (unsigned short)385,
                           (unsigned short)513, (unsigned short)769,
                           (unsigned short)1025, (unsigned short)1537,
                           (unsigned short)2049, (unsigned short)3073,
                           (unsigned short)4097, (unsigned short)6145,
                           (unsigned short)8193, (unsigned short)12289,
                           (unsigned short)16385, (unsigned short)24577};
static ush cpdext[30] =   
                          {(unsigned short)0, (unsigned short)0,
                           (unsigned short)0, (unsigned short)0,
                           (unsigned short)1, (unsigned short)1,
                           (unsigned short)2, (unsigned short)2,
                           (unsigned short)3, (unsigned short)3,
                           (unsigned short)4, (unsigned short)4,
                           (unsigned short)5, (unsigned short)5,
                           (unsigned short)6, (unsigned short)6,
                           (unsigned short)7, (unsigned short)7,
                           (unsigned short)8, (unsigned short)8,
                           (unsigned short)9, (unsigned short)9,
                           (unsigned short)10, (unsigned short)10,
                           (unsigned short)11, (unsigned short)11,
                           (unsigned short)12, (unsigned short)12,
                           (unsigned short)13, (unsigned short)13};
ulg bb;
unsigned int bk;
ush mask_bits[17] =   
                      {(unsigned short)0x0000, (unsigned short)0x0001,
                       (unsigned short)0x0003, (unsigned short)0x0007,
                       (unsigned short)0x000f, (unsigned short)0x001f,
                       (unsigned short)0x003f, (unsigned short)0x007f,
                       (unsigned short)0x00ff, (unsigned short)0x01ff,
                       (unsigned short)0x03ff, (unsigned short)0x07ff,
                       (unsigned short)0x0fff, (unsigned short)0x1fff,
                       (unsigned short)0x3fff, (unsigned short)0x7fff,
                       (unsigned short)0xffff};
int lbits = 9;
int dbits = 6;
unsigned int hufts;
int huft_build(unsigned int *b, unsigned int n, unsigned int s, ush *d,
               ush *e, struct huft **t, int *m) __attribute__((__FC_OLDSTYLEPROTO__));;
int huft_build(unsigned int *b, unsigned int n, unsigned int s, ush *d,
               ush *e, struct huft **t, int *m)
{
  int __retres;
  unsigned int a;
  unsigned int c[16 + 1];
  unsigned int f;
  int g;
  int h;
  register unsigned int i_0;
  register unsigned int j_0;
  register int k;
  int l;
  register unsigned int *p;
  register struct huft *q;
  struct huft r;
  struct huft *u[16];
  unsigned int v[288];
  register int w;
  unsigned int x[16 + 1];
  unsigned int *xp;
  int y;
  unsigned int z;
  char *tmp;
  tmp = convert_uint32s_sint8s(c);
  memset((void *)tmp,0,(unsigned long)sizeof(c));
  p = b;
  i_0 = n;
  while (1) {
    (c[*p]) ++;
    p ++;
    i_0 --;
    
    
    if (! i_0) break;
  }
  
  
  if (c[0] == n) {
    *t = (struct huft *)0;
    *m = 0;
    __retres = 0;
    goto return_label;
  }
  l = *m;
  j_0 = (unsigned int)1;
  while (1) {
    
    
    if (! (j_0 <= (unsigned int)16)) break;
    
    
    if (c[j_0]) break;
    j_0 ++;
  }
  k = (int)j_0;
  
  
  if ((unsigned int)l < j_0) l = (int)j_0;
  i_0 = (unsigned int)16;
  while (1) {
    
    
    if (! i_0) break;
    
    
    if (c[i_0]) break;
    i_0 --;
  }
  g = (int)i_0;
  
  
  if ((unsigned int)l > i_0) l = (int)i_0;
  *m = l;
  y = 1 << j_0;
  while (1) {
    
    
    if (! (j_0 < i_0)) break;
    y = (int)((unsigned int)y - c[j_0]);
    
    
    if (y < 0) {
      __retres = 2;
      goto return_label;
    }
    j_0 ++;
    y <<= 1;
  }
  y = (int)((unsigned int)y - c[i_0]);
  
  
  if (y < 0) {
    __retres = 2;
    goto return_label;
  }
  c[i_0] += (unsigned int)y;
  j_0 = (unsigned int)0;
  x[1] = j_0;
  p = & c[1];
  xp = & x[2];
  while (1) {
    i_0 --;
    
    
    if (! i_0) break;
    {
      unsigned int *tmp_0;
      unsigned int *tmp_1;
      tmp_0 = xp;
      xp ++;
      tmp_1 = p;
      p ++;
      j_0 += *tmp_1;
      *tmp_0 = j_0;
    }
  }
  p = b;
  i_0 = (unsigned int)0;
  while (1) {
    {
      unsigned int *tmp_2;
      tmp_2 = p;
      p ++;
      j_0 = *tmp_2;
      
      
      if (j_0 != (unsigned int)0) {
        unsigned int tmp_3;
        tmp_3 = x[j_0];
        (x[j_0]) ++;
        v[tmp_3] = i_0;
      }
    }
    i_0 ++;
    
    
    if (! (i_0 < n)) break;
  }
  i_0 = (unsigned int)0;
  x[0] = i_0;
  p = v;
  h = -1;
  w = - l;
  u[0] = (struct huft *)0;
  q = (struct huft *)0;
  z = (unsigned int)0;
  while (1) {
    
    
    if (! (k <= g)) break;
    a = c[k];
    while (1) {
      {
        unsigned int tmp_6;
        tmp_6 = a;
        a --;
        
        
        if (! tmp_6) break;
        while (1) {
          {
            void *tmp_7;
            
            
            if (! (k > w + l)) break;
            h ++;
            w += l;
            z = (unsigned int)(g - w);
            
            
            if (z > (unsigned int)l) z = (unsigned int)l; else z = z;
            j_0 = (unsigned int)(k - w);
            f = (unsigned int)(1 << j_0);
            
            
            if (f > a + (unsigned int)1) {
              f -= a + (unsigned int)1;
              xp = & c[k];
              while (1) {
                j_0 ++;
                
                
                if (! (j_0 < z)) break;
                f <<= 1;
                xp ++;
                
                
                if (f <= *xp) break;
                f -= *xp;
              }
            }
            z = (unsigned int)(1 << j_0);
            tmp_7 = malloc((unsigned long)((z + (unsigned int)1) * sizeof(struct huft)));
            q = convert_sint8s_huft((char *)tmp_7);
            
            
            if (q == (struct huft *)0) {
              
              
              if (h) huft_free(u[0]);
              __retres = 3;
              goto return_label;
            }
            hufts += z + (unsigned int)1;
            *t = q + 1;
            t = & q->v.t;
            *t = (struct huft *)0;
            q ++;
            u[h] = q;
            
            
            if (h) {
              x[h] = i_0;
              r.b = (unsigned char)l;
              r.e = (unsigned char)((unsigned int)16 + j_0);
              r.v.t = q;
              j_0 = i_0 >> (w - l);
              *(u[h - 1] + j_0) = r;
            }
          }
        }
        r.b = (unsigned char)(k - w);
        
        
        if (p >= & v[n]) r.e = (unsigned char)99;
        else {
          
          
          if (*p < s) {
            int tmp_4;
            
            
            if (*p < (unsigned int)256) tmp_4 = 16; else tmp_4 = 15;
            r.e = (unsigned char)tmp_4;
            r.v.n = (unsigned short)*p;
            p ++;
          }
          else {
            unsigned int *tmp_5;
            r.e = (unsigned char)*(e + (*p - s));
            tmp_5 = p;
            p ++;
            r.v.n = *(d + (*tmp_5 - s));
          }
        }
        f = (unsigned int)(1 << (k - w));
        j_0 = i_0 >> w;
        while (1) {
          
          
          if (! (j_0 < z)) break;
          *(q + j_0) = r;
          j_0 += f;
        }
        j_0 = (unsigned int)(1 << (k - 1));
        while (1) {
          
          
          if (! (i_0 & j_0)) break;
          i_0 ^= j_0;
          j_0 >>= 1;
        }
        i_0 ^= j_0;
        while (1) {
          
          
          if (! ((i_0 & (unsigned int)((1 << w) - 1)) != x[h])) break;
          h --;
          w -= l;
        }
      }
    }
    k ++;
  }
  __retres = ((y != 0 && g != 1) != 0) != 0;
  return_label: ;
  return __retres;
}

int huft_free(struct huft *t) __attribute__((__FC_OLDSTYLEPROTO__));;
int huft_free(struct huft *t)
{
  int __retres;
  register struct huft *p;
  register struct huft *q;
  p = t;
  while (1) {
    {
      char *tmp;
      
      
      if (! (p != (struct huft *)0)) break;
      p --;
      q = p->v.t;
      tmp = convert_hufts_sint8s((struct hufts *)p);
      free((void *)tmp);
      p = q;
    }
  }
  __retres = 0;
  return __retres;
}

int inflate_codes(struct huft *tl, struct huft *td, int bl, int bd) __attribute__((
__FC_OLDSTYLEPROTO__));;
int inflate_codes(struct huft *tl, struct huft *td, int bl, int bd)
{
  int __retres;
  register unsigned int e;
  unsigned int n;
  unsigned int d;
  unsigned int w;
  struct huft *t;
  unsigned int ml;
  unsigned int md;
  register ulg b;
  register unsigned int k;
  b = bb;
  k = bk;
  w = outcnt;
  ml = (unsigned int)mask_bits[bl];
  md = (unsigned int)mask_bits[bd];
  while (1) {
    while (1) {
      
      
      if (! (k < (unsigned int)bl)) break;
      {
        int tmp_1;
        
        
        if (inptr < insize) {
          unsigned int tmp;
          tmp = inptr;
          inptr ++;
          tmp_1 = (int)inbuf[tmp];
        }
        else tmp_1 = fill_inbuf(0);
        b |= (unsigned long)((unsigned char)tmp_1) << k;
        k += (unsigned int)8;
      }
    }
    t = tl + ((unsigned int)b & ml);
    e = (unsigned int)t->e;
    
    
    if (e > (unsigned int)16) 
      while (1) {
        
        
        if (e == (unsigned int)99) {
          __retres = 1;
          goto return_label;
        }
        b >>= (int)t->b;
        k -= (unsigned int)t->b;
        e -= (unsigned int)16;
        while (1) {
          
          
          if (! (k < e)) break;
          {
            int tmp_4;
            
            
            if (inptr < insize) {
              unsigned int tmp_2;
              tmp_2 = inptr;
              inptr ++;
              tmp_4 = (int)inbuf[tmp_2];
            }
            else tmp_4 = fill_inbuf(0);
            b |= (unsigned long)((unsigned char)tmp_4) << k;
            k += (unsigned int)8;
          }
        }
        t = t->v.t + ((unsigned int)b & (unsigned int)mask_bits[e]);
        e = (unsigned int)t->e;
        
        
        if (! (e > (unsigned int)16)) break;
      }
    b >>= (int)t->b;
    k -= (unsigned int)t->b;
    
    
    if (e == (unsigned int)16) {
      unsigned int tmp_5;
      tmp_5 = w;
      w ++;
      window[tmp_5] = (unsigned char)t->v.n;
      
      
      if (w == (unsigned int)0x8000) {
        outcnt = w;
        flush_window();
        w = (unsigned int)0;
      }
    }
    else {
      
      
      if (e == (unsigned int)15) break;
      while (1) {
        
        
        if (! (k < e)) break;
        {
          int tmp_8;
          
          
          if (inptr < insize) {
            unsigned int tmp_6;
            tmp_6 = inptr;
            inptr ++;
            tmp_8 = (int)inbuf[tmp_6];
          }
          else tmp_8 = fill_inbuf(0);
          b |= (unsigned long)((unsigned char)tmp_8) << k;
          k += (unsigned int)8;
        }
      }
      n = (unsigned int)t->v.n + ((unsigned int)b & (unsigned int)mask_bits[e]);
      b >>= e;
      k -= e;
      while (1) {
        
        
        if (! (k < (unsigned int)bd)) break;
        {
          int tmp_11;
          
          
          if (inptr < insize) {
            unsigned int tmp_9;
            tmp_9 = inptr;
            inptr ++;
            tmp_11 = (int)inbuf[tmp_9];
          }
          else tmp_11 = fill_inbuf(0);
          b |= (unsigned long)((unsigned char)tmp_11) << k;
          k += (unsigned int)8;
        }
      }
      t = td + ((unsigned int)b & md);
      e = (unsigned int)t->e;
      
      
      if (e > (unsigned int)16) 
        while (1) {
          
          
          if (e == (unsigned int)99) {
            __retres = 1;
            goto return_label;
          }
          b >>= (int)t->b;
          k -= (unsigned int)t->b;
          e -= (unsigned int)16;
          while (1) {
            
            
            if (! (k < e)) break;
            {
              int tmp_14;
              
              
              if (inptr < insize) {
                unsigned int tmp_12;
                tmp_12 = inptr;
                inptr ++;
                tmp_14 = (int)inbuf[tmp_12];
              }
              else tmp_14 = fill_inbuf(0);
              b |= (unsigned long)((unsigned char)tmp_14) << k;
              k += (unsigned int)8;
            }
          }
          t = t->v.t + ((unsigned int)b & (unsigned int)mask_bits[e]);
          e = (unsigned int)t->e;
          
          
          if (! (e > (unsigned int)16)) break;
        }
      b >>= (int)t->b;
      k -= (unsigned int)t->b;
      while (1) {
        
        
        if (! (k < e)) break;
        {
          int tmp_17;
          
          
          if (inptr < insize) {
            unsigned int tmp_15;
            tmp_15 = inptr;
            inptr ++;
            tmp_17 = (int)inbuf[tmp_15];
          }
          else tmp_17 = fill_inbuf(0);
          b |= (unsigned long)((unsigned char)tmp_17) << k;
          k += (unsigned int)8;
        }
      }
      d = (w - (unsigned int)t->v.n) - ((unsigned int)b & (unsigned int)mask_bits[e]);
      b >>= e;
      k -= e;
      while (1) {
        {
          unsigned int tmp_18;
          d &= (unsigned int)(0x8000 - 1);
          
          
          if (d > w) tmp_18 = d; else tmp_18 = w;
          e = (unsigned int)0x8000 - tmp_18;
          
          
          if (e > n) e = n; else e = e;
          n -= e;
          
          
          if (w - d >= e) {
            char *tmp_19;
            char *tmp_20;
            {
              /*sequence*/
              
              tmp_19 = convert_uint8s_sint8s(& window[d]);
              tmp_20 = convert_uint8s_sint8s(& window[w]);
            }
            memcpy((void *)tmp_20,(void const *)tmp_19,(unsigned long)e);
            w += e;
            d += e;
          }
          else 
            while (1) {
              {
                unsigned int tmp_21;
                unsigned int tmp_22;
                tmp_21 = w;
                w ++;
                tmp_22 = d;
                d ++;
                window[tmp_21] = window[tmp_22];
              }
              e --;
              
              
              if (! e) break;
            }
          
          
          if (w == (unsigned int)0x8000) {
            outcnt = w;
            flush_window();
            w = (unsigned int)0;
          }
        }
        
        
        if (! n) break;
      }
    }
  }
  outcnt = w;
  bb = b;
  bk = k;
  __retres = 0;
  return_label: ;
  return __retres;
}

int inflate_stored(void)
{
  int __retres;
  unsigned int n;
  unsigned int w;
  register ulg b;
  register unsigned int k;
  b = bb;
  k = bk;
  w = outcnt;
  n = k & (unsigned int)7;
  b >>= n;
  k -= n;
  while (1) {
    
    
    if (! (k < (unsigned int)16)) break;
    {
      int tmp_1;
      
      
      if (inptr < insize) {
        unsigned int tmp;
        tmp = inptr;
        inptr ++;
        tmp_1 = (int)inbuf[tmp];
      }
      else tmp_1 = fill_inbuf(0);
      b |= (unsigned long)((unsigned char)tmp_1) << k;
      k += (unsigned int)8;
    }
  }
  n = (unsigned int)b & (unsigned int)0xffff;
  b >>= 16;
  k -= (unsigned int)16;
  while (1) {
    
    
    if (! (k < (unsigned int)16)) break;
    {
      int tmp_4;
      
      
      if (inptr < insize) {
        unsigned int tmp_2;
        tmp_2 = inptr;
        inptr ++;
        tmp_4 = (int)inbuf[tmp_2];
      }
      else tmp_4 = fill_inbuf(0);
      b |= (unsigned long)((unsigned char)tmp_4) << k;
      k += (unsigned int)8;
    }
  }
  
  
  if (n != (unsigned int)(~ b & (unsigned long)0xffff)) {
    __retres = 1;
    goto return_label;
  }
  b >>= 16;
  k -= (unsigned int)16;
  while (1) {
    {
      unsigned int tmp_9;
      tmp_9 = n;
      n --;
      
      
      if (! tmp_9) break;
      {
        unsigned int tmp_8;
        while (1) {
          
          
          if (! (k < (unsigned int)8)) break;
          {
            int tmp_7;
            
            
            if (inptr < insize) {
              unsigned int tmp_5;
              tmp_5 = inptr;
              inptr ++;
              tmp_7 = (int)inbuf[tmp_5];
            }
            else tmp_7 = fill_inbuf(0);
            b |= (unsigned long)((unsigned char)tmp_7) << k;
            k += (unsigned int)8;
          }
        }
        tmp_8 = w;
        w ++;
        window[tmp_8] = (unsigned char)b;
        
        
        if (w == (unsigned int)0x8000) {
          outcnt = w;
          flush_window();
          w = (unsigned int)0;
        }
        b >>= 8;
        k -= (unsigned int)8;
      }
    }
  }
  outcnt = w;
  bb = b;
  bk = k;
  __retres = 0;
  return_label: ;
  return __retres;
}

int inflate_fixed(void)
{
  int __retres;
  int i_0;
  struct huft *tl;
  struct huft *td;
  int bl;
  int bd;
  unsigned int l[288];
  int tmp;
  i_0 = 0;
  while (1) {
    
    
    if (! (i_0 < 144)) break;
    l[i_0] = (unsigned int)8;
    i_0 ++;
  }
  while (1) {
    
    
    if (! (i_0 < 256)) break;
    l[i_0] = (unsigned int)9;
    i_0 ++;
  }
  while (1) {
    
    
    if (! (i_0 < 280)) break;
    l[i_0] = (unsigned int)7;
    i_0 ++;
  }
  while (1) {
    
    
    if (! (i_0 < 288)) break;
    l[i_0] = (unsigned int)8;
    i_0 ++;
  }
  bl = 7;
  i_0 = huft_build(l,(unsigned int)288,(unsigned int)257,cplens,cplext,& tl,
                   & bl);
  
  
  if (i_0 != 0) {
    __retres = i_0;
    goto return_label;
  }
  i_0 = 0;
  while (1) {
    
    
    if (! (i_0 < 30)) break;
    l[i_0] = (unsigned int)5;
    i_0 ++;
  }
  bd = 5;
  i_0 = huft_build(l,(unsigned int)30,(unsigned int)0,cpdist,cpdext,& td,
                   & bd);
  
  
  if (i_0 > 1) {
    huft_free(tl);
    __retres = i_0;
    goto return_label;
  }
  tmp = inflate_codes(tl,td,bl,bd);
  
  
  if (tmp) {
    __retres = 1;
    goto return_label;
  }
  huft_free(tl);
  huft_free(td);
  __retres = 0;
  return_label: ;
  return __retres;
}

int inflate_dynamic(void)
{
  int __retres;
  int i_0;
  unsigned int j_0;
  unsigned int l;
  unsigned int m;
  unsigned int n;
  struct huft *tl;
  struct huft *td;
  int bl;
  int bd;
  unsigned int nb;
  unsigned int nl;
  unsigned int nd;
  unsigned int ll[286 + 30];
  register ulg b;
  register unsigned int k;
  int tmp_30;
  b = bb;
  k = bk;
  while (1) {
    
    
    if (! (k < (unsigned int)5)) break;
    {
      int tmp_1;
      
      
      if (inptr < insize) {
        unsigned int tmp;
        tmp = inptr;
        inptr ++;
        tmp_1 = (int)inbuf[tmp];
      }
      else tmp_1 = fill_inbuf(0);
      b |= (unsigned long)((unsigned char)tmp_1) << k;
      k += (unsigned int)8;
    }
  }
  nl = (unsigned int)257 + ((unsigned int)b & (unsigned int)0x1f);
  b >>= 5;
  k -= (unsigned int)5;
  while (1) {
    
    
    if (! (k < (unsigned int)5)) break;
    {
      int tmp_4;
      
      
      if (inptr < insize) {
        unsigned int tmp_2;
        tmp_2 = inptr;
        inptr ++;
        tmp_4 = (int)inbuf[tmp_2];
      }
      else tmp_4 = fill_inbuf(0);
      b |= (unsigned long)((unsigned char)tmp_4) << k;
      k += (unsigned int)8;
    }
  }
  nd = (unsigned int)1 + ((unsigned int)b & (unsigned int)0x1f);
  b >>= 5;
  k -= (unsigned int)5;
  while (1) {
    
    
    if (! (k < (unsigned int)4)) break;
    {
      int tmp_7;
      
      
      if (inptr < insize) {
        unsigned int tmp_5;
        tmp_5 = inptr;
        inptr ++;
        tmp_7 = (int)inbuf[tmp_5];
      }
      else tmp_7 = fill_inbuf(0);
      b |= (unsigned long)((unsigned char)tmp_7) << k;
      k += (unsigned int)8;
    }
  }
  nb = (unsigned int)4 + ((unsigned int)b & (unsigned int)0xf);
  b >>= 4;
  k -= (unsigned int)4;
  
  
  
  
  if (nl > (unsigned int)286 || nd > (unsigned int)30) {
    __retres = 1;
    goto return_label;
  }
  j_0 = (unsigned int)0;
  while (1) {
    
    
    if (! (j_0 < nb)) break;
    while (1) {
      
      
      if (! (k < (unsigned int)3)) break;
      {
        int tmp_10;
        
        
        if (inptr < insize) {
          unsigned int tmp_8;
          tmp_8 = inptr;
          inptr ++;
          tmp_10 = (int)inbuf[tmp_8];
        }
        else tmp_10 = fill_inbuf(0);
        b |= (unsigned long)((unsigned char)tmp_10) << k;
        k += (unsigned int)8;
      }
    }
    ll[border[j_0]] = (unsigned int)b & (unsigned int)7;
    b >>= 3;
    k -= (unsigned int)3;
    j_0 ++;
  }
  while (1) {
    
    
    if (! (j_0 < (unsigned int)19)) break;
    ll[border[j_0]] = (unsigned int)0;
    j_0 ++;
  }
  bl = 7;
  i_0 = huft_build(ll,(unsigned int)19,(unsigned int)19,(ush *)0,(ush *)0,
                   & tl,& bl);
  
  
  if (i_0 != 0) {
    
    
    if (i_0 == 1) huft_free(tl);
    __retres = i_0;
    goto return_label;
  }
  n = nl + nd;
  m = (unsigned int)mask_bits[bl];
  l = (unsigned int)0;
  i_0 = (int)l;
  while (1) {
    
    
    if (! ((unsigned int)i_0 < n)) break;
    while (1) {
      
      
      if (! (k < (unsigned int)bl)) break;
      {
        int tmp_13;
        
        
        if (inptr < insize) {
          unsigned int tmp_11;
          tmp_11 = inptr;
          inptr ++;
          tmp_13 = (int)inbuf[tmp_11];
        }
        else tmp_13 = fill_inbuf(0);
        b |= (unsigned long)((unsigned char)tmp_13) << k;
        k += (unsigned int)8;
      }
    }
    td = tl + ((unsigned int)b & m);
    j_0 = (unsigned int)td->b;
    b >>= j_0;
    k -= j_0;
    j_0 = (unsigned int)td->v.n;
    
    
    if (j_0 < (unsigned int)16) {
      int tmp_14;
      tmp_14 = i_0;
      i_0 ++;
      l = j_0;
      ll[tmp_14] = l;
    }
    else {
      
      
      if (j_0 == (unsigned int)16) {
        while (1) {
          
          
          if (! (k < (unsigned int)2)) break;
          {
            int tmp_17;
            
            
            if (inptr < insize) {
              unsigned int tmp_15;
              tmp_15 = inptr;
              inptr ++;
              tmp_17 = (int)inbuf[tmp_15];
            }
            else tmp_17 = fill_inbuf(0);
            b |= (unsigned long)((unsigned char)tmp_17) << k;
            k += (unsigned int)8;
          }
        }
        j_0 = (unsigned int)3 + ((unsigned int)b & (unsigned int)3);
        b >>= 2;
        k -= (unsigned int)2;
        
        
        if ((unsigned int)i_0 + j_0 > n) {
          __retres = 1;
          goto return_label;
        }
        while (1) {
          {
            unsigned int tmp_19;
            int tmp_18;
            tmp_19 = j_0;
            j_0 --;
            
            
            if (! tmp_19) break;
            tmp_18 = i_0;
            i_0 ++;
            ll[tmp_18] = l;
          }
        }
      }
      else {
        
        
        if (j_0 == (unsigned int)17) {
          while (1) {
            
            
            if (! (k < (unsigned int)3)) break;
            {
              int tmp_22;
              
              
              if (inptr < insize) {
                unsigned int tmp_20;
                tmp_20 = inptr;
                inptr ++;
                tmp_22 = (int)inbuf[tmp_20];
              }
              else tmp_22 = fill_inbuf(0);
              b |= (unsigned long)((unsigned char)tmp_22) << k;
              k += (unsigned int)8;
            }
          }
          j_0 = (unsigned int)3 + ((unsigned int)b & (unsigned int)7);
          b >>= 3;
          k -= (unsigned int)3;
          
          
          if ((unsigned int)i_0 + j_0 > n) {
            __retres = 1;
            goto return_label;
          }
          while (1) {
            {
              unsigned int tmp_24;
              int tmp_23;
              tmp_24 = j_0;
              j_0 --;
              
              
              if (! tmp_24) break;
              tmp_23 = i_0;
              i_0 ++;
              ll[tmp_23] = (unsigned int)0;
            }
          }
          l = (unsigned int)0;
        }
        else {
          while (1) {
            
            
            if (! (k < (unsigned int)7)) break;
            {
              int tmp_27;
              
              
              if (inptr < insize) {
                unsigned int tmp_25;
                tmp_25 = inptr;
                inptr ++;
                tmp_27 = (int)inbuf[tmp_25];
              }
              else tmp_27 = fill_inbuf(0);
              b |= (unsigned long)((unsigned char)tmp_27) << k;
              k += (unsigned int)8;
            }
          }
          j_0 = (unsigned int)11 + ((unsigned int)b & (unsigned int)0x7f);
          b >>= 7;
          k -= (unsigned int)7;
          
          
          if ((unsigned int)i_0 + j_0 > n) {
            __retres = 1;
            goto return_label;
          }
          while (1) {
            {
              unsigned int tmp_29;
              int tmp_28;
              tmp_29 = j_0;
              j_0 --;
              
              
              if (! tmp_29) break;
              tmp_28 = i_0;
              i_0 ++;
              ll[tmp_28] = (unsigned int)0;
            }
          }
          l = (unsigned int)0;
        }
      }
    }
  }
  huft_free(tl);
  bb = b;
  bk = k;
  bl = lbits;
  i_0 = huft_build(ll,nl,(unsigned int)257,cplens,cplext,& tl,& bl);
  
  
  if (i_0 != 0) {
    
    
    if (i_0 == 1) {
      fprintf(stderr," incomplete literal tree\n");
      huft_free(tl);
    }
    __retres = i_0;
    goto return_label;
  }
  bd = dbits;
  i_0 = huft_build(& ll[nl],nd,(unsigned int)0,cpdist,cpdext,& td,& bd);
  
  
  if (i_0 != 0) {
    
    
    if (i_0 == 1) {
      fprintf(stderr," incomplete distance tree\n");
      huft_free(td);
    }
    huft_free(tl);
    __retres = i_0;
    goto return_label;
  }
  tmp_30 = inflate_codes(tl,td,bl,bd);
  
  
  if (tmp_30) {
    __retres = 1;
    goto return_label;
  }
  huft_free(tl);
  huft_free(td);
  __retres = 0;
  return_label: ;
  return __retres;
}

int inflate_block(int *e) __attribute__((__FC_OLDSTYLEPROTO__));;
int inflate_block(int *e)
{
  int __retres;
  unsigned int t;
  register ulg b;
  register unsigned int k;
  b = bb;
  k = bk;
  while (1) {
    
    
    if (! (k < (unsigned int)1)) break;
    {
      int tmp_1;
      
      
      if (inptr < insize) {
        unsigned int tmp;
        tmp = inptr;
        inptr ++;
        tmp_1 = (int)inbuf[tmp];
      }
      else tmp_1 = fill_inbuf(0);
      b |= (unsigned long)((unsigned char)tmp_1) << k;
      k += (unsigned int)8;
    }
  }
  *e = (int)b & 1;
  b >>= 1;
  k -= (unsigned int)1;
  while (1) {
    
    
    if (! (k < (unsigned int)2)) break;
    {
      int tmp_4;
      
      
      if (inptr < insize) {
        unsigned int tmp_2;
        tmp_2 = inptr;
        inptr ++;
        tmp_4 = (int)inbuf[tmp_2];
      }
      else tmp_4 = fill_inbuf(0);
      b |= (unsigned long)((unsigned char)tmp_4) << k;
      k += (unsigned int)8;
    }
  }
  t = (unsigned int)b & (unsigned int)3;
  b >>= 2;
  k -= (unsigned int)2;
  bb = b;
  bk = k;
  
  
  if (t == (unsigned int)2) {
    int tmp_5;
    tmp_5 = inflate_dynamic();
    __retres = tmp_5;
    goto return_label;
  }
  
  
  if (t == (unsigned int)0) {
    int tmp_6;
    tmp_6 = inflate_stored();
    __retres = tmp_6;
    goto return_label;
  }
  
  
  if (t == (unsigned int)1) {
    int tmp_7;
    tmp_7 = inflate_fixed();
    __retres = tmp_7;
    goto return_label;
  }
  __retres = 2;
  return_label: ;
  return __retres;
}

int inflate(void)
{
  int __retres;
  int e;
  int r;
  unsigned int h;
  outcnt = (unsigned int)0;
  bk = (unsigned int)0;
  bb = (unsigned long)0;
  h = (unsigned int)0;
  while (1) {
    hufts = (unsigned int)0;
    r = inflate_block(& e);
    
    
    if (r != 0) {
      __retres = r;
      goto return_label;
    }
    
    
    if (hufts > h) h = hufts;
    
    
    if (! (! e)) break;
  }
  while (1) {
    
    
    if (! (bk >= (unsigned int)8)) break;
    bk -= (unsigned int)8;
    inptr --;
  }
  outcnt = outcnt;
  flush_window();
  __retres = 0;
  return_label: ;
  return __retres;
}

int lzw(int in, int out) __attribute__((__FC_OLDSTYLEPROTO__));

static int msg_done = 0;
int lzw(int in, int out) __attribute__((__FC_OLDSTYLEPROTO__));;
int lzw(int in, int out)
{
  int __retres;
  
  
  if (msg_done) {
    __retres = 1;
    goto return_label;
  }
  msg_done = 1;
  fprintf(stderr,"output in compress .Z format not supported\n");
  
  
  if (in != out) exit_code = 1;
  __retres = 1;
  return_label: ;
  return __retres;
}

__inline static unsigned int __bswap_67(unsigned int __bsx)
{
  unsigned int __retres;
  int tmp;
  tmp = __builtin_bswap32((int)__bsx);
  __retres = (unsigned int)tmp;
  return __retres;
}

__inline static __uint64_t __bswap_68(__uint64_t __bsx)
{
  __uint64_t __retres;
  int tmp;
  tmp = __builtin_bswap64((int)__bsx);
  __retres = (unsigned long)tmp;
  return __retres;
}

/*@ assigns \nothing; */
extern  __attribute__((__nothrow__)) int atoi(char const *__nptr) __attribute__((
__pure__, __nonnull__(1), __leaf__));

int spec_write(int fd, unsigned char *buf, int size);

/*@ assigns \nothing; */
extern  __attribute__((__nothrow__)) char *strerror(int __errnum) __attribute__((
__leaf__));

void spec_initbufs(void);

void spec_compress(int in, int out, int lev);

void spec_uncompress(int in, int out, int lev);

int dbglvl = 4;
struct spec_fd_t spec_fd[3];
long seedi;
double ran(void)
{
  double __retres;
  long lo;
  long hi;
  long test_0;
  hi = seedi / 127773L;
  lo = seedi % 127773L;
  test_0 = 16807L * lo - 2836L * hi;
  
  
  if (test_0 > (long)0) seedi = test_0; else seedi = test_0 + 2147483647L;
  __retres = (double)((float)seedi / (float)2147483647L);
  return __retres;
}

int spec_init(void)
{
  int __retres;
  int i_0;
  int j_0;
  
  
  if (3 < dbglvl) printf("spec_init\n");
  i_0 = 0;
  while (1) {
    
    
    if (! (i_0 < 3)) break;
    {
      int limit;
      char *tmp;
      void *tmp_0;
      limit = spec_fd[i_0].limit;
      tmp = convert_spec_fd_ts_sint8s(& spec_fd[i_0]);
      memset((void *)tmp,0,(unsigned long)sizeof(spec_fd[0]));
      spec_fd[i_0].limit = limit;
      tmp_0 = malloc((unsigned long)(limit + 100 * 1024));
      spec_fd[i_0].buf = convert_sint8s_uint8s((char *)tmp_0);
      
      
      if (spec_fd[i_0].buf == (void *)0) {
        printf("spec_init: Error mallocing memory!\n");
        exit(1);
      }
      j_0 = 0;
      while (1) {
        
        
        if (! (j_0 < limit)) break;
        *(spec_fd[i_0].buf + j_0) = (unsigned char)0;
        j_0 += 1024;
      }
    }
    i_0 ++;
  }
  __retres = 0;
  return __retres;
}

int spec_random_load(int fd)
{
  int __retres;
  int i_0;
  int j_0;
  char random_text[32][128 * 1024];
  
  
  if (4 < dbglvl) printf("Creating Chunks\n");
  i_0 = 0;
  while (1) {
    
    
    if (! (i_0 < 32)) break;
    
    
    if (5 < dbglvl) printf("Creating Chunk %d\n",i_0);
    j_0 = 0;
    while (1) {
      
      
      if (! (j_0 < 128 * 1024)) break;
      {
        double tmp;
        tmp = ran();
        random_text[i_0][j_0] = (char)((int)(tmp * (double)256));
      }
      j_0 ++;
    }
    i_0 ++;
  }
  
  
  if (4 < dbglvl) printf("Filling input file\n");
  i_0 = 0;
  while (1) {
    
    
    if (! (i_0 < spec_fd[fd].limit)) break;
    {
      double tmp_0;
      char *tmp_1;
      tmp_0 = ran();
      {
        /*sequence*/
        ;
        tmp_1 = convert_uint8s_sint8s(spec_fd[fd].buf + i_0);
      }
      memcpy((void *)tmp_1,
             (void const *)(random_text[(int)(tmp_0 * (double)32)]),
             (unsigned long)(128 * 1024));
    }
    i_0 += 128 * 1024;
  }
  spec_fd[fd].len = 1024 * 1024;
  __retres = 0;
  return __retres;
}

/*@ assigns *x_1; */
extern int read(int x_0, unsigned char *x_1, int x_2);

int spec_load(int num, char *filename, int size)
{
  int __retres;
  int fd;
  int rc;
  int i_0;
  int tmp_1;
  fd = open((char const *)filename,00 | 0);
  
  
  if (fd < 0) {
    char *tmp_0;
    int *tmp;
    tmp = __errno_location();
    tmp_0 = strerror(*tmp);
    fprintf(stderr,"Can\'t open file %s: %s\n",filename,tmp_0);
    exit(1);
  }
  tmp_1 = 0;
  spec_fd[num].len = tmp_1;
  spec_fd[num].pos = tmp_1;
  i_0 = 0;
  while (1) {
    
    
    if (! (i_0 < size)) break;
    rc = read(fd,spec_fd[num].buf + i_0,128 * 1024);
    
    
    if (rc == 0) break;
    
    
    if (rc < 0) {
      char *tmp_3;
      int *tmp_2;
      tmp_2 = __errno_location();
      tmp_3 = strerror(*tmp_2);
      fprintf(stderr,"Error reading from %s: %s\n",filename,tmp_3);
      exit(1);
    }
    spec_fd[num].len += rc;
    i_0 += rc;
  }
  close(fd);
  while (1) {
    
    
    if (! (spec_fd[num].len < size)) break;
    {
      int tmp_4;
      char *tmp_5;
      char *tmp_6;
      tmp_4 = size - spec_fd[num].len;
      
      
      if (tmp_4 > spec_fd[num].len) tmp_4 = spec_fd[num].len;
      
      
      if (3 < dbglvl) printf("Duplicating %d bytes\n",tmp_4);
      {
        /*sequence*/
        ;
        tmp_5 = convert_uint8s_sint8s(spec_fd[num].buf);
        tmp_6 = convert_uint8s_sint8s(spec_fd[num].buf + spec_fd[num].len);
      }
      memcpy((void *)tmp_6,(void const *)tmp_5,(unsigned long)tmp_4);
      spec_fd[num].len += tmp_4;
    }
  }
  __retres = 0;
  return __retres;
}

int spec_read(int fd, unsigned char *buf, int size)
{
  int __retres;
  int rc;
  char *tmp;
  char *tmp_0;
  rc = 0;
  
  
  if (4 < dbglvl) printf("spec_read: %d, %x, %d = ",fd,buf,size);
  
  
  if (fd > 3) {
    fprintf(stderr,"spec_read: fd=%d, > MAX_SPEC_FD!\n",fd);
    exit(1);
  }
  
  
  if (spec_fd[fd].pos >= spec_fd[fd].len) {
    
    
    if (4 < dbglvl) printf("EOF\n");
    __retres = -1;
    goto return_label;
  }
  
  
  if (spec_fd[fd].pos + size >= spec_fd[fd].len) rc = spec_fd[fd].len - spec_fd[fd].pos;
  else rc = size;
  {
    /*sequence*/
    ;
    tmp = convert_uint8s_sint8s(spec_fd[fd].buf + spec_fd[fd].pos);
    tmp_0 = convert_uint8s_sint8s(buf);
  }
  memcpy((void *)tmp_0,(void const *)tmp,(unsigned long)rc);
  spec_fd[fd].pos += rc;
  
  
  if (4 < dbglvl) printf("%d\n",rc);
  __retres = rc;
  return_label: ;
  return __retres;
}

int spec_getc(int fd)
{
  int __retres;
  int rc;
  int tmp;
  rc = 0;
  
  
  if (4 < dbglvl) printf("spec_getc: %d = ",fd);
  
  
  if (fd > 3) {
    fprintf(stderr,"spec_read: fd=%d, > MAX_SPEC_FD!\n",fd);
    exit(1);
  }
  
  
  if (spec_fd[fd].pos >= spec_fd[fd].len) {
    
    
    if (4 < dbglvl) printf("EOF\n");
    __retres = -1;
    goto return_label;
  }
  tmp = spec_fd[fd].pos;
  (spec_fd[fd].pos) ++;
  rc = (int)*(spec_fd[fd].buf + tmp);
  
  
  if (4 < dbglvl) printf("%d\n",rc);
  __retres = rc;
  return_label: ;
  return __retres;
}

int spec_ungetc(unsigned char ch, int fd)
{
  int __retres;
  int rc;
  rc = 0;
  
  
  if (4 < dbglvl) printf("spec_ungetc: %d = ",fd);
  
  
  if (fd > 3) {
    fprintf(stderr,"spec_read: fd=%d, > MAX_SPEC_FD!\n",fd);
    exit(1);
  }
  
  
  if (spec_fd[fd].pos <= 0) {
    fprintf(stderr,"spec_ungetc: pos %d <= 0\n",spec_fd[fd].pos);
    exit(1);
  }
  (spec_fd[fd].pos) --;
  
  
  if ((int)*(spec_fd[fd].buf + spec_fd[fd].pos) != (int)ch) {
    fprintf(stderr,
            "spec_ungetc: can\'t unget something that wasn\'t what was in the buffer!\n");
    exit(1);
  }
  
  
  if (4 < dbglvl) printf("%d\n",rc);
  __retres = (int)ch;
  return __retres;
}

int spec_rewind(int fd)
{
  int __retres;
  spec_fd[fd].pos = 0;
  __retres = 0;
  return __retres;
}

int spec_reset(int fd)
{
  int __retres;
  int tmp;
  char *tmp_0;
  {
    /*sequence*/
    ;
    tmp_0 = convert_uint8s_sint8s(spec_fd[fd].buf);
  }
  memset((void *)tmp_0,0,(unsigned long)spec_fd[fd].len);
  tmp = 0;
  spec_fd[fd].len = tmp;
  spec_fd[fd].pos = tmp;
  __retres = 0;
  return __retres;
}

int spec_write(int fd, unsigned char *buf, int size)
{
  char *tmp;
  char *tmp_0;
  
  
  if (4 < dbglvl) printf("spec_write: %d, %x, %d = ",fd,buf,size);
  
  
  if (fd > 3) {
    fprintf(stderr,"spec_write: fd=%d, > MAX_SPEC_FD!\n",fd);
    exit(1);
  }
  {
    /*sequence*/
    ;
    tmp = convert_uint8s_sint8s(buf);
    tmp_0 = convert_uint8s_sint8s(spec_fd[fd].buf + spec_fd[fd].pos);
  }
  memcpy((void *)tmp_0,(void const *)tmp,(unsigned long)size);
  spec_fd[fd].len += size;
  spec_fd[fd].pos += size;
  
  
  if (4 < dbglvl) printf("%d\n",size);
  return size;
}

int spec_putc(unsigned char ch, int fd)
{
  int __retres;
  int tmp;
  
  
  if (4 < dbglvl) printf("spec_putc: %d, %d = ",(int)ch,fd);
  
  
  if (fd > 3) {
    fprintf(stderr,"spec_write: fd=%d, > MAX_SPEC_FD!\n",fd);
    exit(1);
  }
  tmp = spec_fd[fd].pos;
  (spec_fd[fd].pos) ++;
  *(spec_fd[fd].buf + tmp) = ch;
  (spec_fd[fd].len) ++;
  __retres = (int)ch;
  return __retres;
}

int debug_time(void);

int main(int argc, char **argv)
{
  int __retres;
  int i_0;
  int level_0;
  int input_size;
  int compressed_size;
  char *input_name;
  unsigned char *validate_array;
  void *tmp;
  input_size = 64;
  input_name = (char *)"input.combined";
  seedi = (long)10;
  
  
  if (argc > 1) input_name = *(argv + 1);
  
  
  if (argc > 2) input_size = atoi((char const *)*(argv + 2));
  
  
  if (argc > 3) compressed_size = atoi((char const *)*(argv + 3));
  else compressed_size = input_size;
  spec_fd[0].limit = input_size * (1024 * 1024);
  spec_fd[1].limit = compressed_size * (1024 * 1024);
  spec_fd[2].limit = input_size * (1024 * 1024);
  spec_init();
  debug_time();
  
  
  if (2 < dbglvl) printf("Loading Input Data\n");
  spec_load(0,input_name,input_size * (1024 * 1024));
  
  
  if (3 < dbglvl) printf("Input data %d bytes in length\n",spec_fd[0].len);
  tmp = malloc((unsigned long)((input_size * (1024 * 1024)) / 1024));
  validate_array = convert_sint8s_uint8s((char *)tmp);
  
  
  if (validate_array == (void *)0) {
    printf("main: Error mallocing memory!\n");
    exit(1);
  }
  i_0 = 0;
  while (1) {
    
    
    if (! (i_0 * 1027 < input_size * (1024 * 1024))) break;
    *(validate_array + i_0) = *(spec_fd[0].buf + i_0 * 1027);
    i_0 ++;
  }
  spec_initbufs();
  level_0 = 1;
  while (1) {
    
    
    if (! (level_0 <= 9)) break;
    debug_time();
    
    
    if (2 < dbglvl) printf("Compressing Input Data, level %d\n",level_0);
    spec_compress(0,1,level_0);
    debug_time();
    
    
    if (3 < dbglvl) printf("Compressed data %d bytes in length\n",
                           spec_fd[1].len);
    spec_reset(0);
    spec_rewind(1);
    debug_time();
    
    
    if (2 < dbglvl) printf("Uncompressing Data\n");
    spec_uncompress(1,0,level_0);
    debug_time();
    
    
    if (3 < dbglvl) printf("Uncompressed data %d bytes in length\n",
                           spec_fd[0].len);
    i_0 = 0;
    while (1) {
      
      
      if (! (i_0 * 1027 < input_size * (1024 * 1024))) break;
      

      

      if ((int)*(validate_array + i_0) != (int)*(spec_fd[0].buf + i_0 * 1027)) {
        printf("Tested %dMB buffer: Miscompared!!\n",input_size);
        exit(1);
      }
      i_0 ++;
    }
    debug_time();
    
    
    if (3 < dbglvl) printf("Uncompressed data compared correctly\n");
    spec_reset(1);
    spec_rewind(0);
    level_0 += 2;
  }
  printf("Tested %dMB buffer: OK!\n",input_size);
  __retres = 0;
  return __retres;
}

void spec_initbufs(void)
{
  no_name = 0;
  no_time = 0;
  time_stamp = (long)0;
  save_orig_name = 0;
  ifile_size = -1L;
  to_stdout = 1;
  return;
}

void spec_compress(int in, int out, int lev)
{
  level = lev;
  part_nb = 0;
  clear_bufs();
  ifd = in;
  ofd = out;
  zip(ifd,ofd);
  return;
}

void spec_uncompress(int in, int out, int lev)
{
  level = lev;
  part_nb = 0;
  clear_bufs();
  ifd = in;
  ofd = out;
  method = get_method(1);
  unzip(ifd,ofd);
  return;
}

int debug_time(void)
{
  int __retres;
  __retres = 0;
  return __retres;
}

__inline static unsigned int __bswap_69(unsigned int __bsx)
{
  unsigned int __retres;
  int tmp;
  tmp = __builtin_bswap32((int)__bsx);
  __retres = (unsigned int)tmp;
  return __retres;
}

__inline static __uint64_t __bswap_70(__uint64_t __bsx)
{
  __uint64_t __retres;
  int tmp;
  tmp = __builtin_bswap64((int)__bsx);
  __retres = (unsigned long)tmp;
  return __retres;
}

void ct_init(ush *attr, int *methodp) __attribute__((__FC_OLDSTYLEPROTO__));

void warn(char *a, char *b) __attribute__((__FC_OLDSTYLEPROTO__));

static int extra_lbits[29] =   
                               {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2,
                                2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};
static int extra_dbits[30] =   
                               {0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6,
                                6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12,
                                13, 13};
static int extra_blbits[19] =   
                                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                 0, 2, 3, 7};
static ct_data dyn_ltree[2 * ((256 + 1) + 29) + 1];
static ct_data dyn_dtree[2 * 30 + 1];
static ct_data static_ltree[((256 + 1) + 29) + 2];
static ct_data static_dtree[30];
static ct_data bl_tree[2 * 19 + 1];
static tree_desc l_desc = {.dyn_tree = dyn_ltree,
                           .static_tree = static_ltree,
                           .extra_bits = extra_lbits, .extra_base = 256 + 1,
                           .elems = (256 + 1) + 29, .max_length = 15,
                           .max_code = 0};
static tree_desc d_desc = {.dyn_tree = dyn_dtree,
                           .static_tree = static_dtree,
                           .extra_bits = extra_dbits, .extra_base = 0,
                           .elems = 30, .max_length = 15, .max_code = 0};
static tree_desc bl_desc = {.dyn_tree = bl_tree, .static_tree = (ct_data *)0,
                            .extra_bits = extra_blbits, .extra_base = 0,
                            .elems = 19, .max_length = 7, .max_code = 0};
static ush bl_count[15 + 1];
static uch bl_order[19] =   
                            {(unsigned char)16, (unsigned char)17,
                             (unsigned char)18, (unsigned char)0,
                             (unsigned char)8, (unsigned char)7,
                             (unsigned char)9, (unsigned char)6,
                             (unsigned char)10, (unsigned char)5,
                             (unsigned char)11, (unsigned char)4,
                             (unsigned char)12, (unsigned char)3,
                             (unsigned char)13, (unsigned char)2,
                             (unsigned char)14, (unsigned char)1,
                             (unsigned char)15};
static int heap[2 * ((256 + 1) + 29) + 1];
static int heap_len;
static int heap_max;
static uch depth[2 * ((256 + 1) + 29) + 1];
static uch length_code[(258 - 3) + 1];
static uch dist_code[512];
static int base_length[29];
static int base_dist[30];
static uch flag_buf[0x8000 / 8];
static unsigned int last_lit;
static unsigned int last_dist;
static unsigned int last_flags;
static uch flags;
static uch flag_bit;
static ulg opt_len;
static ulg static_len;
static ulg compressed_len;
static ulg input_len;
ush *file_type;
int *file_method;
static void init_block(void);

static void pqdownheap(ct_data *tree, int k) __attribute__((__FC_OLDSTYLEPROTO__));

static void gen_bitlen(tree_desc *desc) __attribute__((__FC_OLDSTYLEPROTO__));

static void gen_codes(ct_data *tree, int max_code) __attribute__((__FC_OLDSTYLEPROTO__));

static void build_tree(tree_desc *desc) __attribute__((__FC_OLDSTYLEPROTO__));

static void scan_tree(ct_data *tree, int max_code) __attribute__((__FC_OLDSTYLEPROTO__));

static void send_tree(ct_data *tree, int max_code) __attribute__((__FC_OLDSTYLEPROTO__));

static int build_bl_tree(void);

static void send_all_trees(int lcodes, int dcodes, int blcodes) __attribute__((
__FC_OLDSTYLEPROTO__));

static void compress_block(ct_data *ltree, ct_data *dtree) __attribute__((
__FC_OLDSTYLEPROTO__));

static void set_file_type(void);

void ct_init(ush *attr, int *methodp) __attribute__((__FC_OLDSTYLEPROTO__));;
void ct_init(ush *attr, int *methodp)
{
  int n;
  int bits;
  int length;
  int code;
  int dist;
  file_type = attr;
  file_method = methodp;
  input_len = (unsigned long)0L;
  compressed_len = input_len;
  
  
  if ((int)static_dtree[0].dl.len != 0) goto return_label;
  length = 0;
  code = 0;
  while (1) {
    
    
    if (! (code < 29 - 1)) break;
    base_length[code] = length;
    n = 0;
    while (1) {
      
      
      if (! (n < 1 << extra_lbits[code])) break;
      {
        int tmp;
        tmp = length;
        length ++;
        length_code[tmp] = (unsigned char)code;
      }
      n ++;
    }
    code ++;
  }
  length_code[length - 1] = (unsigned char)code;
  dist = 0;
  code = 0;
  while (1) {
    
    
    if (! (code < 16)) break;
    base_dist[code] = dist;
    n = 0;
    while (1) {
      
      
      if (! (n < 1 << extra_dbits[code])) break;
      {
        int tmp_0;
        tmp_0 = dist;
        dist ++;
        dist_code[tmp_0] = (unsigned char)code;
      }
      n ++;
    }
    code ++;
  }
  dist >>= 7;
  while (1) {
    
    
    if (! (code < 30)) break;
    base_dist[code] = dist << 7;
    n = 0;
    while (1) {
      
      
      if (! (n < 1 << (extra_dbits[code] - 7))) break;
      {
        int tmp_1;
        tmp_1 = dist;
        dist ++;
        dist_code[256 + tmp_1] = (unsigned char)code;
      }
      n ++;
    }
    code ++;
  }
  bits = 0;
  while (1) {
    
    
    if (! (bits <= 15)) break;
    bl_count[bits] = (unsigned short)0;
    bits ++;
  }
  n = 0;
  while (1) {
    {
      int tmp_2;
      
      
      if (! (n <= 143)) break;
      tmp_2 = n;
      n ++;
      static_ltree[tmp_2].dl.len = (unsigned short)8;
      bl_count[8] = (unsigned short)((int)bl_count[8] + 1);
    }
  }
  while (1) {
    {
      int tmp_3;
      
      
      if (! (n <= 255)) break;
      tmp_3 = n;
      n ++;
      static_ltree[tmp_3].dl.len = (unsigned short)9;
      bl_count[9] = (unsigned short)((int)bl_count[9] + 1);
    }
  }
  while (1) {
    {
      int tmp_4;
      
      
      if (! (n <= 279)) break;
      tmp_4 = n;
      n ++;
      static_ltree[tmp_4].dl.len = (unsigned short)7;
      bl_count[7] = (unsigned short)((int)bl_count[7] + 1);
    }
  }
  while (1) {
    {
      int tmp_5;
      
      
      if (! (n <= 287)) break;
      tmp_5 = n;
      n ++;
      static_ltree[tmp_5].dl.len = (unsigned short)8;
      bl_count[8] = (unsigned short)((int)bl_count[8] + 1);
    }
  }
  gen_codes(static_ltree,((256 + 1) + 29) + 1);
  n = 0;
  while (1) {
    
    
    if (! (n < 30)) break;
    {
      unsigned int tmp_6;
      static_dtree[n].dl.len = (unsigned short)5;
      tmp_6 = bi_reverse((unsigned int)n,5);
      static_dtree[n].fc.code = (unsigned short)tmp_6;
    }
    n ++;
  }
  init_block();
  return_label: ;
  return;
}

static void init_block(void)
{
  int n;
  n = 0;
  while (1) {
    
    
    if (! (n < (256 + 1) + 29)) break;
    dyn_ltree[n].fc.freq = (unsigned short)0;
    n ++;
  }
  n = 0;
  while (1) {
    
    
    if (! (n < 30)) break;
    dyn_dtree[n].fc.freq = (unsigned short)0;
    n ++;
  }
  n = 0;
  while (1) {
    
    
    if (! (n < 19)) break;
    bl_tree[n].fc.freq = (unsigned short)0;
    n ++;
  }
  dyn_ltree[256].fc.freq = (unsigned short)1;
  static_len = (unsigned long)0L;
  opt_len = static_len;
  last_flags = (unsigned int)0;
  last_dist = last_flags;
  last_lit = last_dist;
  flags = (unsigned char)0;
  flag_bit = (unsigned char)1;
  return;
}

static void pqdownheap(ct_data *tree, int k) __attribute__((__FC_OLDSTYLEPROTO__));;
static void pqdownheap(ct_data *tree, int k)
{
  int v;
  int j_0;
  v = heap[k];
  j_0 = k << 1;
  while (1) {
    
    
    if (! (j_0 <= heap_len)) break;
    
    
    

    

    

    

    
    

    if (j_0 < heap_len && ((int)(tree + heap[j_0 + 1])->fc.freq < (int)(
                           tree + heap[j_0])->fc.freq || ((int)(tree + heap[
                                                                j_0 + 1])->fc.freq == (int)(
                                                          tree + heap[j_0])->fc.freq && 
                                                          (int)depth[heap[
                                                          j_0 + 1]] <= (int)depth[heap[j_0]]))) 
      j_0 ++;
    

    

    

    

    
    
    if ((int)(tree + v)->fc.freq < (int)(tree + heap[j_0])->fc.freq || (
        (int)(tree + v)->fc.freq == (int)(tree + heap[j_0])->fc.freq && 
        (int)depth[v] <= (int)depth[heap[j_0]])) break;
    heap[k] = heap[j_0];
    k = j_0;
    j_0 <<= 1;
  }
  heap[k] = v;
  return;
}

static void gen_bitlen(tree_desc *desc) __attribute__((__FC_OLDSTYLEPROTO__));;
static void gen_bitlen(tree_desc *desc)
{
  ct_data *tree;
  int *extra;
  int base;
  int max_code;
  int max_length;
  ct_data *stree;
  int h;
  int n;
  int m;
  int bits;
  int xbits;
  ush f;
  int overflow;
  tree = desc->dyn_tree;
  extra = desc->extra_bits;
  base = desc->extra_base;
  max_code = desc->max_code;
  max_length = desc->max_length;
  stree = desc->static_tree;
  overflow = 0;
  bits = 0;
  while (1) {
    
    
    if (! (bits <= 15)) break;
    bl_count[bits] = (unsigned short)0;
    bits ++;
  }
  (tree + heap[heap_max])->dl.len = (unsigned short)0;
  h = heap_max + 1;
  while (1) {
    
    
    if (! (h < 2 * ((256 + 1) + 29) + 1)) break;
    n = heap[h];
    bits = (int)(tree + (int)(tree + n)->dl.dad)->dl.len + 1;
    
    
    if (bits > max_length) {
      bits = max_length;
      overflow ++;
    }
    (tree + n)->dl.len = (unsigned short)bits;
    
    
    if (n > max_code) goto __Cont;
    bl_count[bits] = (unsigned short)((int)bl_count[bits] + 1);
    xbits = 0;
    
    
    if (n >= base) xbits = *(extra + (n - base));
    f = (tree + n)->fc.freq;
    opt_len += (unsigned long)f * (unsigned long)(bits + xbits);
    
    
    if (stree) static_len += (unsigned long)f * (unsigned long)((int)(
                                                                stree + n)->dl.len + xbits);
    __Cont: h ++;
  }
  
  
  if (overflow == 0) goto return_label;
  while (1) {
    bits = max_length - 1;
    while (1) {
      
      
      if (! ((int)bl_count[bits] == 0)) break;
      bits --;
    }
    bl_count[bits] = (unsigned short)((int)bl_count[bits] - 1);
    bl_count[bits + 1] = (unsigned short)((int)bl_count[bits + 1] + 2);
    bl_count[max_length] = (unsigned short)((int)bl_count[max_length] - 1);
    overflow -= 2;
    
    
    if (! (overflow > 0)) break;
  }
  bits = max_length;
  while (1) {
    
    
    if (! (bits != 0)) break;
    n = (int)bl_count[bits];
    while (1) {
      
      
      if (! (n != 0)) break;
      h --;
      m = heap[h];
      
      
      if (m > max_code) continue;
      

      

      if ((unsigned int)(tree + m)->dl.len != (unsigned int)bits) {
        opt_len += (unsigned long)(((long)bits - (long)(tree + m)->dl.len) * (long)(
                                   tree + m)->fc.freq);
        (tree + m)->dl.len = (unsigned short)bits;
      }
      n --;
    }
    bits --;
  }
  return_label: ;
  return;
}

static void gen_codes(ct_data *tree, int max_code) __attribute__((__FC_OLDSTYLEPROTO__));;
static void gen_codes(ct_data *tree, int max_code)
{
  ush next_code[15 + 1];
  ush code;
  int bits;
  int n;
  code = (unsigned short)0;
  bits = 1;
  while (1) {
    
    
    if (! (bits <= 15)) break;
    code = (unsigned short)(((int)code + (int)bl_count[bits - 1]) << 1);
    next_code[bits] = code;
    bits ++;
  }
  n = 0;
  while (1) {
    
    
    if (! (n <= max_code)) break;
    {
      int len;
      unsigned int tmp_0;
      ush tmp;
      len = (int)(tree + n)->dl.len;
      
      
      if (len == 0) goto __Cont;
      tmp = next_code[len];
      next_code[len] = (unsigned short)((int)next_code[len] + 1);
      tmp_0 = bi_reverse((unsigned int)tmp,len);
      (tree + n)->fc.code = (unsigned short)tmp_0;
    }
    __Cont: n ++;
  }
  return;
}

static void build_tree(tree_desc *desc) __attribute__((__FC_OLDSTYLEPROTO__));;
static void build_tree(tree_desc *desc)
{
  ct_data *tree;
  ct_data *stree;
  int elems;
  int n;
  int m;
  int max_code;
  int node;
  tree = desc->dyn_tree;
  stree = desc->static_tree;
  elems = desc->elems;
  max_code = -1;
  node = elems;
  heap_len = 0;
  heap_max = 2 * ((256 + 1) + 29) + 1;
  n = 0;
  while (1) {
    
    
    if (! (n < elems)) break;
    
    
    if ((int)(tree + n)->fc.freq != 0) {
      heap_len ++;
      max_code = n;
      heap[heap_len] = max_code;
      depth[n] = (unsigned char)0;
    }
    else (tree + n)->dl.len = (unsigned short)0;
    n ++;
  }
  while (1) {
    
    
    if (! (heap_len < 2)) break;
    {
      int new;
      int tmp;
      heap_len ++;
      
      
      if (max_code < 2) {
        max_code ++;
        tmp = max_code;
      }
      else tmp = 0;
      heap[heap_len] = tmp;
      new = tmp;
      (tree + new)->fc.freq = (unsigned short)1;
      depth[new] = (unsigned char)0;
      opt_len --;
      
      
      if (stree) static_len -= (unsigned long)(stree + new)->dl.len;
    }
  }
  desc->max_code = max_code;
  n = heap_len / 2;
  while (1) {
    
    
    if (! (n >= 1)) break;
    pqdownheap(tree,n);
    n --;
  }
  while (1) {
    {
      int tmp_1;
      ush tmp_2;
      int tmp_3;
      {
        int tmp_0;
        n = heap[1];
        tmp_0 = heap_len;
        heap_len --;
        heap[1] = heap[tmp_0];
        pqdownheap(tree,1);
      }
      m = heap[1];
      heap_max --;
      heap[heap_max] = n;
      heap_max --;
      heap[heap_max] = m;
      (tree + node)->fc.freq = (unsigned short)((int)(tree + n)->fc.freq + (int)(
                                                tree + m)->fc.freq);
      
      
      if ((int)depth[n] >= (int)depth[m]) tmp_1 = (int)depth[n];
      else tmp_1 = (int)depth[m];
      depth[node] = (unsigned char)(tmp_1 + 1);
      tmp_2 = (unsigned short)node;
      (tree + m)->dl.dad = tmp_2;
      (tree + n)->dl.dad = tmp_2;
      tmp_3 = node;
      node ++;
      heap[1] = tmp_3;
      pqdownheap(tree,1);
    }
    
    
    if (! (heap_len >= 2)) break;
  }
  heap_max --;
  heap[heap_max] = heap[1];
  gen_bitlen(desc);
  gen_codes(tree,max_code);
  return;
}

static void scan_tree(ct_data *tree, int max_code) __attribute__((__FC_OLDSTYLEPROTO__));;
static void scan_tree(ct_data *tree, int max_code)
{
  int n;
  int prevlen;
  int curlen;
  int nextlen;
  int count;
  int max_count;
  int min_count;
  prevlen = -1;
  nextlen = (int)(tree + 0)->dl.len;
  count = 0;
  max_count = 7;
  min_count = 4;
  
  
  if (nextlen == 0) {
    max_count = 138;
    min_count = 3;
  }
  (tree + (max_code + 1))->dl.len = (unsigned short)0xffff;
  n = 0;
  while (1) {
    
    
    if (! (n <= max_code)) break;
    curlen = nextlen;
    nextlen = (int)(tree + (n + 1))->dl.len;
    count ++;
    
    
    if (count < max_count) {
      
      
      if (curlen == nextlen) goto __Cont; else goto _LAND;
    }
    else {
      _LAND: ;
      
      
      if (count < min_count) bl_tree[curlen].fc.freq = (unsigned short)(
                             (int)bl_tree[curlen].fc.freq + count);
      else {
        
        
        if (curlen != 0) {
          
          
          if (curlen != prevlen) bl_tree[curlen].fc.freq = (unsigned short)(
                                 (int)bl_tree[curlen].fc.freq + 1);
          bl_tree[16].fc.freq = (unsigned short)((int)bl_tree[16].fc.freq + 1);
        }
        else {
          
          
          if (count <= 10) bl_tree[17].fc.freq = (unsigned short)((int)bl_tree[17].fc.freq + 1);
          else bl_tree[18].fc.freq = (unsigned short)((int)bl_tree[18].fc.freq + 1);
        }
      }
    }
    count = 0;
    prevlen = curlen;
    
    
    if (nextlen == 0) {
      max_count = 138;
      min_count = 3;
    }
    else {
      
      
      if (curlen == nextlen) {
        max_count = 6;
        min_count = 3;
      }
      else {
        max_count = 7;
        min_count = 4;
      }
    }
    __Cont: n ++;
  }
  return;
}

static void send_tree(ct_data *tree, int max_code) __attribute__((__FC_OLDSTYLEPROTO__));;
static void send_tree(ct_data *tree, int max_code)
{
  int n;
  int prevlen;
  int curlen;
  int nextlen;
  int count;
  int max_count;
  int min_count;
  prevlen = -1;
  nextlen = (int)(tree + 0)->dl.len;
  count = 0;
  max_count = 7;
  min_count = 4;
  
  
  if (nextlen == 0) {
    max_count = 138;
    min_count = 3;
  }
  n = 0;
  while (1) {
    
    
    if (! (n <= max_code)) break;
    curlen = nextlen;
    nextlen = (int)(tree + (n + 1))->dl.len;
    count ++;
    
    
    if (count < max_count) {
      
      
      if (curlen == nextlen) goto __Cont; else goto _LAND;
    }
    else {
      _LAND: ;
      
      
      if (count < min_count) 
        while (1) {
          send_bits((int)bl_tree[curlen].fc.code,(int)bl_tree[curlen].dl.len);
          count --;
          
          
          if (! (count != 0)) break;
        }
      else {
        
        
        if (curlen != 0) {
          
          
          if (curlen != prevlen) {
            send_bits((int)bl_tree[curlen].fc.code,
                      (int)bl_tree[curlen].dl.len);
            count --;
          }
          send_bits((int)bl_tree[16].fc.code,(int)bl_tree[16].dl.len);
          send_bits(count - 3,2);
        }
        else {
          
          
          if (count <= 10) {
            send_bits((int)bl_tree[17].fc.code,(int)bl_tree[17].dl.len);
            send_bits(count - 3,3);
          }
          else {
            send_bits((int)bl_tree[18].fc.code,(int)bl_tree[18].dl.len);
            send_bits(count - 11,7);
          }
        }
      }
    }
    count = 0;
    prevlen = curlen;
    
    
    if (nextlen == 0) {
      max_count = 138;
      min_count = 3;
    }
    else {
      
      
      if (curlen == nextlen) {
        max_count = 6;
        min_count = 3;
      }
      else {
        max_count = 7;
        min_count = 4;
      }
    }
    __Cont: n ++;
  }
  return;
}

static int build_bl_tree(void)
{
  int max_blindex;
  scan_tree(dyn_ltree,l_desc.max_code);
  scan_tree(dyn_dtree,d_desc.max_code);
  build_tree(& bl_desc);
  max_blindex = 19 - 1;
  while (1) {
    
    
    if (! (max_blindex >= 3)) break;
    
    
    if ((int)bl_tree[bl_order[max_blindex]].dl.len != 0) break;
    max_blindex --;
  }
  opt_len += (unsigned long)(((3 * (max_blindex + 1) + 5) + 5) + 4);
  return max_blindex;
}

static void send_all_trees(int lcodes, int dcodes, int blcodes) __attribute__((
__FC_OLDSTYLEPROTO__));;
static void send_all_trees(int lcodes, int dcodes, int blcodes)
{
  int rank;
  send_bits(lcodes - 257,5);
  send_bits(dcodes - 1,5);
  send_bits(blcodes - 4,4);
  rank = 0;
  while (1) {
    
    
    if (! (rank < blcodes)) break;
    send_bits((int)bl_tree[bl_order[rank]].dl.len,3);
    rank ++;
  }
  send_tree(dyn_ltree,lcodes - 1);
  send_tree(dyn_dtree,dcodes - 1);
  return;
}

ulg flush_block(char *buf, ulg stored_len, int eof) __attribute__((__FC_OLDSTYLEPROTO__));;
ulg flush_block(char *buf, ulg stored_len, int eof)
{
  ulg __retres;
  ulg opt_lenb;
  ulg static_lenb;
  int max_blindex;
  flag_buf[last_flags] = flags;
  
  
  if ((int)*file_type == (int)((unsigned short)0xffff)) set_file_type();
  build_tree(& l_desc);
  build_tree(& d_desc);
  max_blindex = build_bl_tree();
  opt_lenb = ((opt_len + (unsigned long)3) + (unsigned long)7) >> 3;
  static_lenb = ((static_len + (unsigned long)3) + (unsigned long)7) >> 3;
  input_len += stored_len;
  
  
  if (static_lenb <= opt_lenb) opt_lenb = static_lenb;
  
  
  
  
  
  
  
  
  if (((stored_len <= opt_lenb && eof) && compressed_len == (unsigned long)0L) && 0) {
    
    
    if (buf == (char *)0) error((char *)"block vanished");
    copy_block(buf,(unsigned int)stored_len,0);
    compressed_len = stored_len << 3;
    *file_method = 0;
  }
  else {
    
    
    
    
    if (stored_len + (unsigned long)4 <= opt_lenb && buf != (char *)0) {
      send_bits((0 << 1) + eof,3);
      compressed_len = ((compressed_len + (unsigned long)3) + (unsigned long)7) & (unsigned long)(~ 7L);
      compressed_len += (stored_len + (unsigned long)4) << 3;
      copy_block(buf,(unsigned int)stored_len,1);
    }
    else {
      
      
      if (static_lenb == opt_lenb) {
        send_bits((1 << 1) + eof,3);
        compress_block(static_ltree,static_dtree);
        compressed_len += (unsigned long)3 + static_len;
      }
      else {
        send_bits((2 << 1) + eof,3);
        send_all_trees(l_desc.max_code + 1,d_desc.max_code + 1,
                       max_blindex + 1);
        compress_block(dyn_ltree,dyn_dtree);
        compressed_len += (unsigned long)3 + opt_len;
      }
    }
  }
  init_block();
  
  
  if (eof) {
    bi_windup();
    compressed_len += (unsigned long)7;
  }
  __retres = compressed_len >> 3;
  return __retres;
}

int ct_tally(int dist, int lc) __attribute__((__FC_OLDSTYLEPROTO__));;
int ct_tally(int dist, int lc)
{
  int __retres;
  unsigned int tmp;
  tmp = last_lit;
  last_lit ++;
  inbuf[tmp] = (unsigned char)lc;
  
  
  if (dist == 0) dyn_ltree[lc].fc.freq = (unsigned short)((int)dyn_ltree[lc].fc.freq + 1);
  else {
    int tmp_0;
    unsigned int tmp_1;
    dist --;
    dyn_ltree[((int)length_code[lc] + 256) + 1].fc.freq = (unsigned short)(
    (int)dyn_ltree[((int)length_code[lc] + 256) + 1].fc.freq + 1);
    
    
    if (dist < 256) tmp_0 = (int)dist_code[dist];
    else tmp_0 = (int)dist_code[256 + (dist >> 7)];
    dyn_dtree[tmp_0].fc.freq = (unsigned short)((int)dyn_dtree[tmp_0].fc.freq + 1);
    tmp_1 = last_dist;
    last_dist ++;
    d_buf[tmp_1] = (unsigned short)dist;
    flags = (unsigned char)((int)flags | (int)flag_bit);
  }
  flag_bit = (unsigned char)((int)flag_bit << 1);
  
  
  if ((last_lit & (unsigned int)7) == (unsigned int)0) {
    unsigned int tmp_2;
    tmp_2 = last_flags;
    last_flags ++;
    flag_buf[tmp_2] = flags;
    flags = (unsigned char)0;
    flag_bit = (unsigned char)1;
  }
  
  
  
  
  if (level > 2 && (last_lit & (unsigned int)0xfff) == (unsigned int)0) {
    ulg out_length;
    ulg in_length;
    int dcode;
    out_length = (unsigned long)last_lit * (unsigned long)8L;
    in_length = (unsigned long)strstart - (unsigned long)block_start;
    dcode = 0;
    while (1) {
      
      
      if (! (dcode < 30)) break;
      out_length += (unsigned long)dyn_dtree[dcode].fc.freq * (unsigned long)(
                    5L + (long)extra_dbits[dcode]);
      dcode ++;
    }
    out_length >>= 3;
    
    
    
    
    if (last_dist < last_lit / (unsigned int)2 && out_length < in_length / (unsigned long)2) {
      __retres = 1;
      goto return_label;
    }
  }
  __retres = ((last_lit == (unsigned int)(0x8000 - 1) || last_dist == (unsigned int)0x8000) != 0) != 0;
  return_label: ;
  return __retres;
}

static void compress_block(ct_data *ltree, ct_data *dtree) __attribute__((
__FC_OLDSTYLEPROTO__));;
static void compress_block(ct_data *ltree, ct_data *dtree)
{
  unsigned int dist;
  int lc;
  unsigned int lx;
  unsigned int dx;
  unsigned int fx;
  uch flag;
  unsigned int code;
  int extra;
  lx = (unsigned int)0;
  dx = (unsigned int)0;
  fx = (unsigned int)0;
  flag = (unsigned char)0;
  
  
  if (last_lit != (unsigned int)0) 
    while (1) {
      {
        unsigned int tmp_0;
        
        
        if ((lx & (unsigned int)7) == (unsigned int)0) {
          unsigned int tmp;
          tmp = fx;
          fx ++;
          flag = flag_buf[tmp];
        }
        tmp_0 = lx;
        lx ++;
        lc = (int)inbuf[tmp_0];
        
        
        if (((int)flag & 1) == 0) send_bits((int)(ltree + lc)->fc.code,
                                            (int)(ltree + lc)->dl.len);
        else {
          unsigned int tmp_1;
          code = (unsigned int)length_code[lc];
          send_bits((int)(ltree + ((code + (unsigned int)256) + (unsigned int)1))->fc.code,
                    (int)(ltree + ((code + (unsigned int)256) + (unsigned int)1))->dl.len);
          extra = extra_lbits[code];
          
          
          if (extra != 0) {
            lc -= base_length[code];
            send_bits(lc,extra);
          }
          tmp_1 = dx;
          dx ++;
          dist = (unsigned int)d_buf[tmp_1];
          
          
          if (dist < (unsigned int)256) code = (unsigned int)dist_code[dist];
          else code = (unsigned int)dist_code[(unsigned int)256 + (dist >> 7)];
          send_bits((int)(dtree + code)->fc.code,(int)(dtree + code)->dl.len);
          extra = extra_dbits[code];
          
          
          if (extra != 0) {
            dist -= (unsigned int)base_dist[code];
            send_bits((int)dist,extra);
          }
        }
        flag = (unsigned char)((int)flag >> 1);
      }
      
      
      if (! (lx < last_lit)) break;
    }
  send_bits((int)(ltree + 256)->fc.code,(int)(ltree + 256)->dl.len);
  return;
}

static void set_file_type(void)
{
  int n;
  unsigned int ascii_freq;
  unsigned int bin_freq;
  n = 0;
  ascii_freq = (unsigned int)0;
  bin_freq = (unsigned int)0;
  while (1) {
    {
      int tmp;
      
      
      if (! (n < 7)) break;
      tmp = n;
      n ++;
      bin_freq += (unsigned int)dyn_ltree[tmp].fc.freq;
    }
  }
  while (1) {
    {
      int tmp_0;
      
      
      if (! (n < 128)) break;
      tmp_0 = n;
      n ++;
      ascii_freq += (unsigned int)dyn_ltree[tmp_0].fc.freq;
    }
  }
  while (1) {
    {
      int tmp_1;
      
      
      if (! (n < 256)) break;
      tmp_1 = n;
      n ++;
      bin_freq += (unsigned int)dyn_ltree[tmp_1].fc.freq;
    }
  }
  
  
  if (bin_freq > ascii_freq >> 2) *file_type = (unsigned short)0;
  else *file_type = (unsigned short)1;
  
  
  
  
  if ((int)*file_type == 0 && 0) warn((char *)"-l used on binary file",
                                      (char *)"");
  return;
}

void write_buf(int fd, voidp buf, unsigned int cnt) __attribute__((__FC_OLDSTYLEPROTO__));

static unsigned int decode(unsigned int count, uch *buffer) __attribute__((
__FC_OLDSTYLEPROTO__));

static void decode_start(void);

static void huf_decode_start(void);

static unsigned int decode_c(void);

static unsigned int decode_p(void);

static void read_pt_len(int nn, int nbit, int i_special) __attribute__((
__FC_OLDSTYLEPROTO__));

static void read_c_len(void);

static void fillbuf(int n) __attribute__((__FC_OLDSTYLEPROTO__));

static unsigned int getbits(int n) __attribute__((__FC_OLDSTYLEPROTO__));

static void init_getbits(void);

static void make_table(int nchar, uch *bitlen, int tablebits, ush *table) __attribute__((
__FC_OLDSTYLEPROTO__));

static uch pt_len[16 + 3];
static unsigned int blocksize;
static ush pt_table[256];
static ush bitbuf;
static unsigned int subbitbuf;
static int bitcount;
static void fillbuf(int n) __attribute__((__FC_OLDSTYLEPROTO__));;
static void fillbuf(int n)
{
  bitbuf = (unsigned short)((int)bitbuf << n);
  while (1) {
    
    
    if (! (n > bitcount)) break;
    {
      int tmp_1;
      n -= bitcount;
      bitbuf = (unsigned short)((unsigned int)bitbuf | (subbitbuf << n));
      
      
      if (inptr < insize) {
        unsigned int tmp;
        tmp = inptr;
        inptr ++;
        tmp_1 = (int)inbuf[tmp];
      }
      else tmp_1 = fill_inbuf(1);
      subbitbuf = (unsigned int)tmp_1;
      
      
      if ((int)subbitbuf == -1) subbitbuf = (unsigned int)0;
      bitcount = 8;
    }
  }
  bitcount -= n;
  bitbuf = (unsigned short)((unsigned int)bitbuf | (subbitbuf >> bitcount));
  return;
}

static unsigned int getbits(int n) __attribute__((__FC_OLDSTYLEPROTO__));;
static unsigned int getbits(int n)
{
  unsigned int x;
  x = (unsigned int)((int)bitbuf >> ((unsigned int)(8 * 2) * sizeof(char) - (unsigned int)n));
  fillbuf(n);
  return x;
}

static void init_getbits(void)
{
  bitbuf = (unsigned short)0;
  subbitbuf = (unsigned int)0;
  bitcount = 0;
  fillbuf((int)((unsigned int)(8 * 2) * sizeof(char)));
  return;
}

static void make_table(int nchar, uch *bitlen, int tablebits, ush *table) __attribute__((
__FC_OLDSTYLEPROTO__));;
static void make_table(int nchar, uch *bitlen, int tablebits, ush *table)
{
  ush count[17];
  ush weight[17];
  ush start[18];
  ush *p;
  unsigned int i_0;
  unsigned int k;
  unsigned int len;
  unsigned int ch;
  unsigned int jutbits;
  unsigned int avail;
  unsigned int nextcode;
  unsigned int mask;
  i_0 = (unsigned int)1;
  while (1) {
    
    
    if (! (i_0 <= (unsigned int)16)) break;
    count[i_0] = (unsigned short)0;
    i_0 ++;
  }
  i_0 = (unsigned int)0;
  while (1) {
    
    
    if (! (i_0 < (unsigned int)nchar)) break;
    count[*(bitlen + i_0)] = (unsigned short)((int)count[*(bitlen + i_0)] + 1);
    i_0 ++;
  }
  start[1] = (unsigned short)0;
  i_0 = (unsigned int)1;
  while (1) {
    
    
    if (! (i_0 <= (unsigned int)16)) break;
    start[i_0 + (unsigned int)1] = (unsigned short)((int)start[i_0] + (
                                                    (int)count[i_0] << (
                                                    (unsigned int)16 - i_0)));
    i_0 ++;
  }
  
  
  if (((int)start[17] & 0xffff) != 0) error((char *)"Bad table\n");
  jutbits = (unsigned int)(16 - tablebits);
  i_0 = (unsigned int)1;
  while (1) {
    
    
    if (! (i_0 <= (unsigned int)tablebits)) break;
    start[i_0] = (unsigned short)((int)start[i_0] >> jutbits);
    weight[i_0] = (unsigned short)((unsigned int)1 << ((unsigned int)tablebits - i_0));
    i_0 ++;
  }
  while (1) {
    
    
    if (! (i_0 <= (unsigned int)16)) break;
    weight[i_0] = (unsigned short)((unsigned int)1 << ((unsigned int)16 - i_0));
    i_0 ++;
  }
  i_0 = (unsigned int)((int)start[tablebits + 1] >> jutbits);
  
  
  if (i_0 != (unsigned int)0) {
    k = (unsigned int)(1 << tablebits);
    while (1) {
      {
        unsigned int tmp;
        
        
        if (! (i_0 != k)) break;
        tmp = i_0;
        i_0 ++;
        *(table + tmp) = (unsigned short)0;
      }
    }
  }
  avail = (unsigned int)nchar;
  mask = (unsigned int)1 << (15 - tablebits);
  ch = (unsigned int)0;
  while (1) {
    
    
    if (! (ch < (unsigned int)nchar)) break;
    len = (unsigned int)*(bitlen + ch);
    
    
    if (len == (unsigned int)0) goto __Cont;
    nextcode = (unsigned int)((int)start[len] + (int)weight[len]);
    
    
    if (len <= (unsigned int)tablebits) {
      i_0 = (unsigned int)start[len];
      while (1) {
        
        
        if (! (i_0 < nextcode)) break;
        *(table + i_0) = (unsigned short)ch;
        i_0 ++;
      }
    }
    else {
      k = (unsigned int)start[len];
      p = table + (k >> jutbits);
      i_0 = len - (unsigned int)tablebits;
      while (1) {
        
        
        if (! (i_0 != (unsigned int)0)) break;
        
        
        if ((int)*p == 0) {
          ush tmp_0;
          unsigned int tmp_1;
          tmp_0 = (unsigned short)0;
          prev[avail] = tmp_0;
          *(& prev[0x8000] + avail) = tmp_0;
          tmp_1 = avail;
          avail ++;
          *p = (unsigned short)tmp_1;
        }
        
        
        if (k & mask) p = & prev[0x8000] + (int)*p; else p = & prev[*p];
        k <<= 1;
        i_0 --;
      }
      *p = (unsigned short)ch;
    }
    start[len] = (unsigned short)nextcode;
    __Cont: ch ++;
  }
  return;
}

static void read_pt_len(int nn, int nbit, int i_special) __attribute__((
__FC_OLDSTYLEPROTO__));;
static void read_pt_len(int nn, int nbit, int i_special)
{
  int i_0;
  int c;
  int n;
  unsigned int mask;
  unsigned int tmp;
  tmp = getbits(nbit);
  n = (int)tmp;
  
  
  if (n == 0) {
    unsigned int tmp_0;
    tmp_0 = getbits(nbit);
    c = (int)tmp_0;
    i_0 = 0;
    while (1) {
      
      
      if (! (i_0 < nn)) break;
      pt_len[i_0] = (unsigned char)0;
      i_0 ++;
    }
    i_0 = 0;
    while (1) {
      
      
      if (! (i_0 < 256)) break;
      pt_table[i_0] = (unsigned short)c;
      i_0 ++;
    }
  }
  else {
    i_0 = 0;
    while (1) {
      
      
      if (! (i_0 < n)) break;
      {
        int tmp_1;
        int tmp_2;
        c = (int)bitbuf >> ((unsigned int)(8 * 2) * sizeof(char) - (unsigned int)3);
        
        
        if (c == 7) {
          mask = (unsigned int)1 << (((unsigned int)(8 * 2) * sizeof(char) - (unsigned int)1) - (unsigned int)3);
          while (1) {
            
            
            if (! (mask & (unsigned int)bitbuf)) break;
            mask >>= 1;
            c ++;
          }
        }
        
        
        if (c < 7) tmp_1 = 3; else tmp_1 = c - 3;
        fillbuf(tmp_1);
        tmp_2 = i_0;
        i_0 ++;
        pt_len[tmp_2] = (unsigned char)c;
        
        
        if (i_0 == i_special) {
          unsigned int tmp_3;
          tmp_3 = getbits(2);
          c = (int)tmp_3;
          while (1) {
            {
              int tmp_4;
              c --;
              
              
              if (! (c >= 0)) break;
              tmp_4 = i_0;
              i_0 ++;
              pt_len[tmp_4] = (unsigned char)0;
            }
          }
        }
      }
    }
    while (1) {
      {
        int tmp_5;
        
        
        if (! (i_0 < nn)) break;
        tmp_5 = i_0;
        i_0 ++;
        pt_len[tmp_5] = (unsigned char)0;
      }
    }
    make_table(nn,pt_len,8,pt_table);
  }
  return;
}

static void read_c_len(void)
{
  int i_0;
  int c;
  int n;
  unsigned int mask;
  unsigned int tmp;
  tmp = getbits(9);
  n = (int)tmp;
  
  
  if (n == 0) {
    unsigned int tmp_0;
    tmp_0 = getbits(9);
    c = (int)tmp_0;
    i_0 = 0;
    while (1) {
      
      
      if (! (i_0 < ((255 + 256) + 2) - 3)) break;
      outbuf[i_0] = (unsigned char)0;
      i_0 ++;
    }
    i_0 = 0;
    while (1) {
      
      
      if (! (i_0 < 4096)) break;
      d_buf[i_0] = (unsigned short)c;
      i_0 ++;
    }
  }
  else {
    i_0 = 0;
    while (1) {
      
      
      if (! (i_0 < n)) break;
      c = (int)pt_table[(int)bitbuf >> ((unsigned int)(8 * 2) * sizeof(char) - (unsigned int)8)];
      
      
      if (c >= 16 + 3) {
        mask = (unsigned int)1 << (((unsigned int)(8 * 2) * sizeof(char) - (unsigned int)1) - (unsigned int)8);
        while (1) {
          
          
          if ((unsigned int)bitbuf & mask) c = (int)*(& prev[0x8000] + c);
          else c = (int)prev[c];
          mask >>= 1;
          
          
          if (! (c >= 16 + 3)) break;
        }
      }
      fillbuf((int)pt_len[c]);
      
      
      if (c <= 2) {
        
        
        if (c == 0) c = 1;
        else {
          
          
          if (c == 1) {
            unsigned int tmp_1;
            tmp_1 = getbits(4);
            c = (int)(tmp_1 + (unsigned int)3);
          }
          else {
            unsigned int tmp_2;
            tmp_2 = getbits(9);
            c = (int)(tmp_2 + (unsigned int)20);
          }
        }
        while (1) {
          {
            int tmp_3;
            c --;
            
            
            if (! (c >= 0)) break;
            tmp_3 = i_0;
            i_0 ++;
            outbuf[tmp_3] = (unsigned char)0;
          }
        }
      }
      else {
        int tmp_4;
        tmp_4 = i_0;
        i_0 ++;
        outbuf[tmp_4] = (unsigned char)(c - 2);
      }
    }
    while (1) {
      {
        int tmp_5;
        
        
        if (! (i_0 < ((255 + 256) + 2) - 3)) break;
        tmp_5 = i_0;
        i_0 ++;
        outbuf[tmp_5] = (unsigned char)0;
      }
    }
    make_table(((255 + 256) + 2) - 3,outbuf,12,d_buf);
  }
  return;
}

static unsigned int decode_c(void)
{
  unsigned int __retres;
  unsigned int j_0;
  unsigned int mask;
  
  
  if (blocksize == (unsigned int)0) {
    blocksize = getbits(16);
    
    
    if (blocksize == (unsigned int)0) {
      __retres = (unsigned int)(((255 + 256) + 2) - 3);
      goto return_label;
    }
    read_pt_len(16 + 3,5,3);
    read_c_len();
    read_pt_len(13 + 1,4,-1);
  }
  blocksize --;
  j_0 = (unsigned int)d_buf[(int)bitbuf >> ((unsigned int)(8 * 2) * sizeof(char) - (unsigned int)12)];
  
  
  if (j_0 >= (unsigned int)(((255 + 256) + 2) - 3)) {
    mask = (unsigned int)1 << (((unsigned int)(8 * 2) * sizeof(char) - (unsigned int)1) - (unsigned int)12);
    while (1) {
      
      
      if ((unsigned int)bitbuf & mask) j_0 = (unsigned int)*(& prev[0x8000] + j_0);
      else j_0 = (unsigned int)prev[j_0];
      mask >>= 1;
      
      
      if (! (j_0 >= (unsigned int)(((255 + 256) + 2) - 3))) break;
    }
  }
  fillbuf((int)outbuf[j_0]);
  __retres = j_0;
  return_label: ;
  return __retres;
}

static unsigned int decode_p(void)
{
  unsigned int j_0;
  unsigned int mask;
  j_0 = (unsigned int)pt_table[(int)bitbuf >> ((unsigned int)(8 * 2) * sizeof(char) - (unsigned int)8)];
  
  
  if (j_0 >= (unsigned int)(13 + 1)) {
    mask = (unsigned int)1 << (((unsigned int)(8 * 2) * sizeof(char) - (unsigned int)1) - (unsigned int)8);
    while (1) {
      
      
      if ((unsigned int)bitbuf & mask) j_0 = (unsigned int)*(& prev[0x8000] + j_0);
      else j_0 = (unsigned int)prev[j_0];
      mask >>= 1;
      
      
      if (! (j_0 >= (unsigned int)(13 + 1))) break;
    }
  }
  fillbuf((int)pt_len[j_0]);
  
  
  if (j_0 != (unsigned int)0) {
    unsigned int tmp;
    tmp = getbits((int)(j_0 - (unsigned int)1));
    j_0 = ((unsigned int)1 << (j_0 - (unsigned int)1)) + tmp;
  }
  return j_0;
}

static void huf_decode_start(void)
{
  init_getbits();
  blocksize = (unsigned int)0;
  return;
}

static int j;
static int done;
static void decode_start(void)
{
  huf_decode_start();
  j = 0;
  done = 0;
  return;
}

static unsigned int i;
static unsigned int decode(unsigned int count, uch *buffer) __attribute__((
__FC_OLDSTYLEPROTO__));;
static unsigned int decode(unsigned int count, uch *buffer)
{
  unsigned int __retres;
  unsigned int r;
  unsigned int c;
  r = (unsigned int)0;
  while (1) {
    j --;
    
    
    if (! (j >= 0)) break;
    *(buffer + r) = *(buffer + i);
    i = (i + (unsigned int)1) & (((unsigned int)1 << 13) - (unsigned int)1);
    r ++;
    
    
    if (r == count) {
      __retres = r;
      goto return_label;
    }
  }
  while (1) {
    c = decode_c();
    
    
    if (c == (unsigned int)(((255 + 256) + 2) - 3)) {
      done = 1;
      __retres = r;
      goto return_label;
    }
    
    
    if (c <= (unsigned int)255) {
      *(buffer + r) = (unsigned char)c;
      r ++;
      
      
      if (r == count) {
        __retres = r;
        goto return_label;
      }
    }
    else {
      unsigned int tmp;
      j = (int)(c - (unsigned int)((255 + 1) - 3));
      tmp = decode_p();
      i = ((r - tmp) - (unsigned int)1) & (((unsigned int)1 << 13) - (unsigned int)1);
      while (1) {
        j --;
        
        
        if (! (j >= 0)) break;
        *(buffer + r) = *(buffer + i);
        i = (i + (unsigned int)1) & (((unsigned int)1 << 13) - (unsigned int)1);
        r ++;
        
        
        if (r == count) {
          __retres = r;
          goto return_label;
        }
      }
    }
  }
  return_label: ;
  return __retres;
}

int unlzh(int in, int out) __attribute__((__FC_OLDSTYLEPROTO__));;
int unlzh(int in, int out)
{
  int __retres;
  unsigned int n;
  ifd = in;
  ofd = out;
  decode_start();
  while (1) {
    
    
    if (! (! done)) break;
    n = decode((unsigned int)1 << 13,window);
    
    
    
    
    if (! test && n > (unsigned int)0) {
      char *tmp;
      {
        /*sequence*/
        ;
        tmp = convert_uint8s_sint8s(window);
        ;
      }
      write_buf(out,(void *)tmp,n);
    }
  }
  __retres = 0;
  return __retres;
}

__inline static unsigned int __bswap_71(unsigned int __bsx)
{
  unsigned int __retres;
  int tmp;
  tmp = __builtin_bswap32((int)__bsx);
  __retres = (unsigned int)tmp;
  return __retres;
}

__inline static __uint64_t __bswap_72(__uint64_t __bsx)
{
  __uint64_t __retres;
  int tmp;
  tmp = __builtin_bswap64((int)__bsx);
  __retres = (unsigned long)tmp;
  return __retres;
}

int block_mode;

int block_mode = 0x80;
int unlzw(int in, int out) __attribute__((__FC_OLDSTYLEPROTO__));;
int unlzw(int in, int out)
{
  int __retres;
  register char_type *stackp;
  code_int code;
  int finchar;
  code_int oldcode;
  code_int incode;
  long inbits;
  long posbits;
  int outpos;
  unsigned int bitmask;
  code_int free_ent;
  code_int maxcode;
  code_int maxmaxcode;
  int n_bits;
  int rsize;
  char *tmp_0;
  
  
  if (inptr < insize) {
    unsigned int tmp;
    tmp = inptr;
    inptr ++;
    maxbits = (int)inbuf[tmp];
  }
  else maxbits = fill_inbuf(0);
  block_mode = maxbits & 0x80;
  
  
  if ((maxbits & 0x60) != 0) {
    
    
    if (! quiet) fprintf(stderr,"\n%s: %s: warning, unknown flags 0x%x\n",
                         progname,ifname,maxbits & 0x60);
    
    
    if (exit_code == 0) exit_code = 2;
  }
  maxbits &= 0x1f;
  maxmaxcode = 1L << maxbits;
  
  
  if (maxbits > 16) {
    fprintf(stderr,
            "\n%s: %s: compressed with %d bits, can only handle %d bits\n",
            progname,ifname,maxbits,16);
    exit_code = 1;
    __retres = 1;
    goto return_label;
  }
  rsize = (int)insize;
  n_bits = 9;
  maxcode = (1L << n_bits) - (long)1;
  bitmask = (unsigned int)((1 << n_bits) - 1);
  oldcode = (long)(-1);
  finchar = 0;
  outpos = 0;
  posbits = (long)(inptr << 3);
  
  
  if (block_mode) free_ent = (long)(256 + 1); else free_ent = (long)256;
  tmp_0 = convert_uint16s_sint8s(prev);
  memset((void *)tmp_0,0,(unsigned long)256);
  code = (long)255;
  while (1) {
    
    
    if (! (code >= (long)0)) break;
    window[code] = (unsigned char)code;
    code --;
  }
  while (1) {
    {
      register int i_0;
      int e;
      int o;
      o = (int)(posbits >> 3);
      e = (int)(insize - (unsigned int)o);
      i_0 = 0;
      while (1) {
        
        
        if (! (i_0 < e)) break;
        inbuf[i_0] = inbuf[i_0 + o];
        i_0 ++;
      }
      insize = (unsigned int)e;
      posbits = (long)0;
      
      
      if (insize < (unsigned int)64) {
        unsigned char *tmp_2;
        char *tmp_1;
        {
          /*sequence*/
          {
            /*sequence*/
            tmp_1 = convert_uint8s_sint8s(inbuf);
            ;
          }
          tmp_2 = convert_sint8s_uint8s(tmp_1 + insize);
          ;
        }
        rsize = spec_read(in,tmp_2,0x8000);
        
        
        if (rsize == -1) read_error();
        insize += (unsigned int)rsize;
        bytes_in = (long)((unsigned long)bytes_in + (unsigned long)rsize);
      }
      
      
      if (rsize != 0) inbits = (long)(((unsigned long)((long)insize) - (unsigned long)(
                                       insize % (unsigned int)n_bits)) << 3);
      else inbits = ((long)insize << 3) - (long)(n_bits - 1);
      while (1) {
        
        
        if (! (inbits > posbits)) break;
        
        
        if (free_ent > maxcode) {
          posbits = (posbits - (long)1) + ((long)(n_bits << 3) - ((posbits - (long)1) + (long)(
                                                                  n_bits << 3)) % (long)(
                                                                 n_bits << 3));
          n_bits ++;
          
          
          if (n_bits == maxbits) maxcode = maxmaxcode;
          else maxcode = (1L << n_bits) - (long)1;
          bitmask = (unsigned int)((1 << n_bits) - 1);
        }
        {
          register char_type *p;
          p = & inbuf[posbits >> 3];
          code = (long)((unsigned long)((((long)*(p + 0) | ((long)*(p + 1) << 8)) | (
                                         (long)*(p + 2) << 16)) >> (posbits & (long)0x7)) & (unsigned long)bitmask);
          posbits += (long)n_bits;
        }
        
        
        if (oldcode == (long)(-1)) {
          int tmp_3;
          
          
          if (code >= (long)256) error((char *)"corrupt input.");
          tmp_3 = outpos;
          outpos ++;
          oldcode = code;
          finchar = (int)oldcode;
          outbuf[tmp_3] = (unsigned char)finchar;
          continue;
        }
        
        
        
        
        if (code == (long)256 && block_mode) {
          char *tmp_4;
          tmp_4 = convert_uint16s_sint8s(prev);
          memset((void *)tmp_4,0,(unsigned long)256);
          free_ent = (long)((256 + 1) - 1);
          posbits = (posbits - (long)1) + ((long)(n_bits << 3) - ((posbits - (long)1) + (long)(
                                                                  n_bits << 3)) % (long)(
                                                                 n_bits << 3));
          n_bits = 9;
          maxcode = (1L << n_bits) - (long)1;
          bitmask = (unsigned int)((1 << n_bits) - 1);
        }
        incode = code;
        stackp = convert_uint16s_uint8s(& d_buf[0x8000 - 1]);
        
        
        if (code >= free_ent) {
          
          
          if (code > free_ent) {
            char const *tmp_5;
            
            
            
            
            if (! test && outpos > 0) {
              char *tmp_6;
              {
                /*sequence*/
                ;
                tmp_6 = convert_uint8s_sint8s(outbuf);
                ;
              }
              write_buf(out,(void *)tmp_6,(unsigned int)outpos);
              bytes_out = (long)((unsigned long)bytes_out + (unsigned long)outpos);
            }
            
            
            if (to_stdout) tmp_5 = "corrupt input.";
            else tmp_5 = "corrupt input. Use zcat to recover some data.";
            error((char *)tmp_5);
          }
          stackp --;
          *stackp = (unsigned char)finchar;
          code = oldcode;
        }
        while (1) {
          
          
          if (! ((unsigned long)code >= (unsigned long)256)) break;
          stackp --;
          *stackp = window[code];
          code = (long)prev[code];
        }
        stackp --;
        finchar = (int)window[code];
        *stackp = (unsigned char)finchar;
        {
          register int i_1;
          {
            unsigned char *tmp_7;
            {
              /*sequence*/
              tmp_7 = convert_uint16s_uint8s(& d_buf[0x8000 - 1]);
              i_1 = tmp_7 - stackp;
            }
          }
          
          
          if (outpos + i_1 >= 16384) 
            while (1) {
              {
                unsigned char *tmp_11;
                
                
                if (i_1 > 16384 - outpos) i_1 = 16384 - outpos;
                
                
                if (i_1 > 0) {
                  char *tmp_8;
                  char *tmp_9;
                  {
                    /*sequence*/
                    ;
                    tmp_8 = convert_uint8s_sint8s(stackp);
                    tmp_9 = convert_uint8s_sint8s(& outbuf[outpos]);
                  }
                  memcpy((void *)tmp_9,(void const *)tmp_8,
                         (unsigned long)i_1);
                  outpos += i_1;
                }
                
                
                if (outpos >= 16384) {
                  
                  
                  if (! test) {
                    char *tmp_10;
                    {
                      /*sequence*/
                      ;
                      tmp_10 = convert_uint8s_sint8s(outbuf);
                      ;
                    }
                    write_buf(out,(void *)tmp_10,(unsigned int)outpos);
                    bytes_out = (long)((unsigned long)bytes_out + (unsigned long)outpos);
                  }
                  outpos = 0;
                }
                stackp += i_1;
                {
                  /*sequence*/
                  tmp_11 = convert_uint16s_uint8s(& d_buf[0x8000 - 1]);
                  i_1 = tmp_11 - stackp;
                }
                
                
                if (! (i_1 > 0)) break;
              }
            }
          else {
            char *tmp_12;
            char *tmp_13;
            {
              /*sequence*/
              ;
              tmp_12 = convert_uint8s_sint8s(stackp);
              tmp_13 = convert_uint8s_sint8s(& outbuf[outpos]);
            }
            memcpy((void *)tmp_13,(void const *)tmp_12,(unsigned long)i_1);
            outpos += i_1;
          }
        }
        code = free_ent;
        
        
        if (code < maxmaxcode) {
          prev[code] = (unsigned short)oldcode;
          window[code] = (unsigned char)finchar;
          free_ent = code + (long)1;
        }
        oldcode = incode;
      }
    }
    
    
    if (! (rsize != 0)) break;
  }
  
  
  
  
  if (! test && outpos > 0) {
    char *tmp_14;
    {
      /*sequence*/
      ;
      tmp_14 = convert_uint8s_sint8s(outbuf);
      ;
    }
    write_buf(out,(void *)tmp_14,(unsigned int)outpos);
    bytes_out = (long)((unsigned long)bytes_out + (unsigned long)outpos);
  }
  __retres = 0;
  return_label: ;
  return __retres;
}

static ulg orig_len;
static int max_len;
static uch literal[256];
static int lit_base[25 + 1];
static int leaves[25 + 1];
static int parents[25 + 1];
static int peek_bits;
static ulg bitbuf_0;
static int valid;
static void read_tree(void);

static void build_tree_0(void);

static void read_tree(void)
{
  int len;
  int base;
  int n;
  int tmp_4;
  orig_len = (unsigned long)0;
  n = 1;
  while (1) {
    {
      int tmp_1;
      
      
      if (! (n <= 4)) break;
      
      
      if (inptr < insize) {
        unsigned int tmp;
        tmp = inptr;
        inptr ++;
        tmp_1 = (int)inbuf[tmp];
      }
      else tmp_1 = fill_inbuf(0);
      orig_len = (orig_len << 8) | (unsigned long)tmp_1;
      n ++;
    }
  }
  
  
  if (inptr < insize) {
    unsigned int tmp_2;
    tmp_2 = inptr;
    inptr ++;
    tmp_4 = (int)inbuf[tmp_2];
  }
  else tmp_4 = fill_inbuf(0);
  max_len = tmp_4;
  
  
  if (max_len > 25) error((char *)"invalid compressed data -- Huffman code > 32 bits");
  n = 0;
  len = 1;
  while (1) {
    
    
    if (! (len <= max_len)) break;
    {
      int tmp_7;
      
      
      if (inptr < insize) {
        unsigned int tmp_5;
        tmp_5 = inptr;
        inptr ++;
        tmp_7 = (int)inbuf[tmp_5];
      }
      else tmp_7 = fill_inbuf(0);
      leaves[len] = tmp_7;
      n += leaves[len];
    }
    len ++;
  }
  
  
  if (n > 256) error((char *)"too many leaves in Huffman tree");
  (leaves[max_len]) ++;
  base = 0;
  len = 1;
  while (1) {
    
    
    if (! (len <= max_len)) break;
    lit_base[len] = base;
    n = leaves[len];
    while (1) {
      
      
      if (! (n > 0)) break;
      {
        int tmp_8;
        int tmp_11;
        tmp_8 = base;
        base ++;
        
        
        if (inptr < insize) {
          unsigned int tmp_9;
          tmp_9 = inptr;
          inptr ++;
          tmp_11 = (int)inbuf[tmp_9];
        }
        else tmp_11 = fill_inbuf(0);
        literal[tmp_8] = (unsigned char)tmp_11;
      }
      n --;
    }
    len ++;
  }
  (leaves[max_len]) ++;
  return;
}

static void build_tree_0(void)
{
  int nodes;
  int len;
  uch *prefixp;
  nodes = 0;
  len = max_len;
  while (1) {
    
    
    if (! (len >= 1)) break;
    nodes >>= 1;
    parents[len] = nodes;
    lit_base[len] -= nodes;
    nodes += leaves[len];
    len --;
  }
  
  
  if (max_len <= 12) peek_bits = max_len; else peek_bits = 12;
  prefixp = & outbuf[1 << peek_bits];
  len = 1;
  while (1) {
    
    
    if (! (len <= peek_bits)) break;
    {
      int prefixes;
      prefixes = leaves[len] << (peek_bits - len);
      while (1) {
        {
          int tmp;
          tmp = prefixes;
          prefixes --;
          
          
          if (! tmp) break;
          prefixp --;
          *prefixp = (unsigned char)len;
        }
      }
    }
    len ++;
  }
  while (1) {
    
    
    if (! (prefixp > outbuf)) break;
    prefixp --;
    *prefixp = (unsigned char)0;
  }
  return;
}

int unpack(int in, int out) __attribute__((__FC_OLDSTYLEPROTO__));;
int unpack(int in, int out)
{
  int __retres;
  int len;
  unsigned int eob;
  register unsigned int peek;
  unsigned int peek_mask;
  ifd = in;
  ofd = out;
  read_tree();
  build_tree_0();
  valid = 0;
  bitbuf_0 = (unsigned long)0;
  peek_mask = (unsigned int)((1 << peek_bits) - 1);
  eob = (unsigned int)(leaves[max_len] - 1);
  while (1) {
    while (1) {
      {
        int tmp_1;
        
        
        if (! (valid < peek_bits)) break;
        
        
        if (inptr < insize) {
          unsigned int tmp;
          tmp = inptr;
          inptr ++;
          tmp_1 = (int)inbuf[tmp];
        }
        else tmp_1 = fill_inbuf(0);
        bitbuf_0 = (bitbuf_0 << 8) | (unsigned long)tmp_1;
        valid += 8;
      }
    }
    peek = (unsigned int)((bitbuf_0 >> (valid - peek_bits)) & (unsigned long)peek_mask);
    len = (int)outbuf[peek];
    
    
    if (len > 0) peek >>= peek_bits - len;
    else {
      ulg mask;
      mask = (unsigned long)peek_mask;
      len = peek_bits;
      while (1) {
        len ++;
        mask = (mask << 1) + (unsigned long)1;
        while (1) {
          {
            int tmp_4;
            
            
            if (! (valid < len)) break;
            
            
            if (inptr < insize) {
              unsigned int tmp_2;
              tmp_2 = inptr;
              inptr ++;
              tmp_4 = (int)inbuf[tmp_2];
            }
            else tmp_4 = fill_inbuf(0);
            bitbuf_0 = (bitbuf_0 << 8) | (unsigned long)tmp_4;
            valid += 8;
          }
        }
        peek = (unsigned int)((bitbuf_0 >> (valid - len)) & mask);
        
        
        if (! (peek < (unsigned int)parents[len])) break;
      }
    }
    
    
    
    
    if (peek == eob && len == max_len) break;
    {
      unsigned int tmp_5;
      tmp_5 = outcnt;
      outcnt ++;
      window[tmp_5] = literal[peek + (unsigned int)lit_base[len]];
      
      
      if (outcnt == (unsigned int)0x8000) flush_window();
    }
    valid -= len;
  }
  flush_window();
  
  
  if (orig_len != (unsigned long)bytes_out) error((char *)"invalid compressed data--length error");
  __retres = 0;
  return __retres;
}

int decrypt;
ulg updcrc(uch *s, unsigned int n) __attribute__((__FC_OLDSTYLEPROTO__));

char *key;
int pkzip = 0;
int ext_header = 0;
int check_zipfile(int in) __attribute__((__FC_OLDSTYLEPROTO__));;
int check_zipfile(int in)
{
  int __retres;
  uch *h;
  h = & inbuf[inptr];
  ifd = in;
  inptr += (unsigned int)((30 + ((int)((unsigned short)*((h + 26) + 0)) | (
                                 (int)((unsigned short)*((h + 26) + 1)) << 8))) + (
                          (int)((unsigned short)*((h + 28) + 0)) | ((int)((unsigned short)*(
                                                                    (
                                                                    h + 28) + 1)) << 8)));
  
  
  

  if (inptr > insize || ((unsigned long)((int)((unsigned short)*(h + 0)) | (
                                         (int)((unsigned short)*(h + 1)) << 8)) | (
                         (unsigned long)((int)((unsigned short)*((h + 2) + 0)) | (
                                         (int)((unsigned short)*((h + 2) + 1)) << 8)) << 16)) != (unsigned long)0x04034b50L) {
    fprintf(stderr,"\n%s: %s: not a valid zip file\n",progname,ifname);
    exit_code = 1;
    __retres = 1;
    goto return_label;
  }
  method = (int)*(h + 8);
  
  
  
  
  if (method != 0 && method != 8) {
    fprintf(stderr,
            "\n%s: %s: first entry not deflated or stored -- use unzip\n",
            progname,ifname);
    exit_code = 1;
    __retres = 1;
    goto return_label;
  }
  decrypt = (int)*(h + 6) & 1;
  
  
  if (decrypt != 0) {
    fprintf(stderr,"\n%s: %s: encrypted file -- use unzip\n",progname,ifname);
    exit_code = 1;
    __retres = 1;
    goto return_label;
  }
  ext_header = ((int)*(h + 6) & 8) != 0;
  pkzip = 1;
  __retres = 0;
  return_label: ;
  return __retres;
}

int unzip(int in, int out) __attribute__((__FC_OLDSTYLEPROTO__));;
int unzip(int in, int out)
{
  int __retres;
  ulg orig_crc;
  ulg orig_len_0;
  int n;
  uch buf[16];
  ulg tmp_12;
  orig_crc = (unsigned long)0;
  orig_len_0 = (unsigned long)0;
  ifd = in;
  ofd = out;
  updcrc((uch *)0,(unsigned int)0);
  
  
  
  
  if (pkzip && ! ext_header) {
    orig_crc = (unsigned long)((int)((unsigned short)*(& inbuf[14] + 0)) | (
                               (int)((unsigned short)*(& inbuf[14] + 1)) << 8)) | (
               (unsigned long)((int)((unsigned short)*((& inbuf[14] + 2) + 0)) | (
                               (int)((unsigned short)*((& inbuf[14] + 2) + 1)) << 8)) << 16);
    orig_len_0 = (unsigned long)((int)((unsigned short)*(& inbuf[22] + 0)) | (
                                 (int)((unsigned short)*(& inbuf[22] + 1)) << 8)) | (
                 (unsigned long)((int)((unsigned short)*((& inbuf[22] + 2) + 0)) | (
                                 (int)((unsigned short)*((& inbuf[22] + 2) + 1)) << 8)) << 16);
  }
  
  
  if (method == 8) {
    int res;
    res = inflate();
    
    
    if (res == 3) error((char *)"out of memory");
    else {
      
      
      if (res != 0) error((char *)"invalid compressed data--format violated");
    }
  }
  else {
    
    
    
    
    if (pkzip && method == 0) {
      register ulg n_0;
      int tmp_0;
      n_0 = (unsigned long)((int)((unsigned short)*(& inbuf[22] + 0)) | (
                            (int)((unsigned short)*(& inbuf[22] + 1)) << 8)) | (
            (unsigned long)((int)((unsigned short)*((& inbuf[22] + 2) + 0)) | (
                            (int)((unsigned short)*((& inbuf[22] + 2) + 1)) << 8)) << 16);
      
      
      if (decrypt) tmp_0 = 12; else tmp_0 = 0;

      if (n_0 != ((unsigned long)((int)((unsigned short)*(& inbuf[18] + 0)) | (
                                  (int)((unsigned short)*(& inbuf[18] + 1)) << 8)) | (
                  (unsigned long)((int)((unsigned short)*((& inbuf[18] + 2) + 0)) | (
                                  (int)((unsigned short)*((& inbuf[18] + 2) + 1)) << 8)) << 16)) - (unsigned long)tmp_0) {
        fprintf(stderr,"len %ld, siz %ld\n",n_0,
                (unsigned long)((int)((unsigned short)*(& inbuf[18] + 0)) | (
                                (int)((unsigned short)*(& inbuf[18] + 1)) << 8)) | (
                (unsigned long)((int)((unsigned short)*((& inbuf[18] + 2) + 0)) | (
                                (int)((unsigned short)*((& inbuf[18] + 2) + 1)) << 8)) << 16));
        error((char *)"invalid compressed data--length mismatch");
      }
      while (1) {
        {
          ulg tmp_5;
          tmp_5 = n_0;
          n_0 --;
          
          
          if (! tmp_5) break;
          {
            uch c;
            int tmp_3;
            
            
            if (inptr < insize) {
              unsigned int tmp_1;
              tmp_1 = inptr;
              inptr ++;
              tmp_3 = (int)inbuf[tmp_1];
            }
            else tmp_3 = fill_inbuf(0);
            c = (unsigned char)tmp_3;
            {
              unsigned int tmp_4;
              tmp_4 = outcnt;
              outcnt ++;
              window[tmp_4] = c;
              
              
              if (outcnt == (unsigned int)0x8000) flush_window();
            }
          }
        }
      }
      flush_window();
    }
    else error((char *)"internal error, invalid method");
  }
  
  
  if (! pkzip) {
    n = 0;
    while (1) {
      
      
      if (! (n < 8)) break;
      {
        int tmp_8;
        
        
        if (inptr < insize) {
          unsigned int tmp_6;
          tmp_6 = inptr;
          inptr ++;
          tmp_8 = (int)inbuf[tmp_6];
        }
        else tmp_8 = fill_inbuf(0);
        buf[n] = (unsigned char)tmp_8;
      }
      n ++;
    }
    orig_crc = (unsigned long)((int)((unsigned short)buf[0]) | ((int)((unsigned short)buf[1]) << 8)) | (
               (unsigned long)((int)((unsigned short)*(& buf[2] + 0)) | (
                               (int)((unsigned short)*(& buf[2] + 1)) << 8)) << 16);
    orig_len_0 = (unsigned long)((int)((unsigned short)*(& buf[4] + 0)) | (
                                 (int)((unsigned short)*(& buf[4] + 1)) << 8)) | (
                 (unsigned long)((int)((unsigned short)*((& buf[4] + 2) + 0)) | (
                                 (int)((unsigned short)*((& buf[4] + 2) + 1)) << 8)) << 16);
  }
  else {
    
    
    if (ext_header) {
      n = 0;
      while (1) {
        
        
        if (! (n < 16)) break;
        {
          int tmp_11;
          
          
          if (inptr < insize) {
            unsigned int tmp_9;
            tmp_9 = inptr;
            inptr ++;
            tmp_11 = (int)inbuf[tmp_9];
          }
          else tmp_11 = fill_inbuf(0);
          buf[n] = (unsigned char)tmp_11;
        }
        n ++;
      }
      orig_crc = (unsigned long)((int)((unsigned short)*(& buf[4] + 0)) | (
                                 (int)((unsigned short)*(& buf[4] + 1)) << 8)) | (
                 (unsigned long)((int)((unsigned short)*((& buf[4] + 2) + 0)) | (
                                 (int)((unsigned short)*((& buf[4] + 2) + 1)) << 8)) << 16);
      orig_len_0 = (unsigned long)((int)((unsigned short)*(& buf[12] + 0)) | (
                                   (int)((unsigned short)*(& buf[12] + 1)) << 8)) | (
                   (unsigned long)((int)((unsigned short)*((& buf[12] + 2) + 0)) | (
                                   (int)((unsigned short)*((& buf[12] + 2) + 1)) << 8)) << 16);
    }
  }
  tmp_12 = updcrc(outbuf,(unsigned int)0);
  
  
  if (orig_crc != tmp_12) error((char *)"invalid compressed data--crc error");
  
  
  if (orig_len_0 != (unsigned long)bytes_out) error((char *)"invalid compressed data--length error");
  
  
  
  
  if ((pkzip && inptr + (unsigned int)4 < insize) && ((unsigned long)(
                                                      (int)((unsigned short)*(
                                                      & inbuf[inptr] + 0)) | (
                                                      (int)((unsigned short)*(
                                                      & inbuf[inptr] + 1)) << 8)) | (
                                                      (unsigned long)(
                                                      (int)((unsigned short)*(
                                                      (& inbuf[inptr] + 2) + 0)) | (
                                                      (int)((unsigned short)*(
                                                      (& inbuf[inptr] + 2) + 1)) << 8)) << 16)) == (unsigned long)0x04034b50L) {
    
    
    if (to_stdout) {
      
      
      if (! quiet) fprintf(stderr,
                           "%s: %s has more than one entry--rest ignored\n",
                           progname,ifname);
      
      
      if (exit_code == 0) exit_code = 2;
    }
    else {
      fprintf(stderr,"%s: %s has more than one entry -- unchanged\n",
              progname,ifname);
      exit_code = 1;
      pkzip = 0;
      ext_header = pkzip;
      __retres = 1;
      goto return_label;
    }
  }
  pkzip = 0;
  ext_header = pkzip;
  __retres = 0;
  return_label: ;
  return __retres;
}

__inline static unsigned int __bswap_73(unsigned int __bsx)
{
  unsigned int __retres;
  int tmp;
  tmp = __builtin_bswap32((int)__bsx);
  __retres = (unsigned int)tmp;
  return __retres;
}

__inline static __uint64_t __bswap_74(__uint64_t __bsx)
{
  __uint64_t __retres;
  int tmp;
  tmp = __builtin_bswap64((int)__bsx);
  __retres = (unsigned long)tmp;
  return __retres;
}

/*@ assigns \nothing; */
extern  __attribute__((__nothrow__)) char **calloc(size_t __nmemb,
                                                   size_t __size) __attribute__((
__malloc__, __leaf__));

/*@ assigns \nothing; */
extern  __attribute__((__nothrow__)) char *getenv(char const *__name) __attribute__((
__nonnull__(1), __leaf__));

/*@ assigns *__fp; */
extern int _IO_putc(int __c, _IO_FILE *__fp);

/*@ assigns \nothing; */
extern  __attribute__((__nothrow__)) size_t strspn(char const *__s,
                                                   char const *__accept) __attribute__((
__pure__, __nonnull__(1,2), __leaf__));

void make_simple_name(char *name) __attribute__((__FC_OLDSTYLEPROTO__));

char *add_envopt(int *argcp, char ***argvp, char *env_0) __attribute__((
__FC_OLDSTYLEPROTO__));

voidp xmalloc(unsigned int size) __attribute__((__FC_OLDSTYLEPROTO__));

ulg crc_32_tab[256];

int copy(int in, int out) __attribute__((__FC_OLDSTYLEPROTO__));;
int copy(int in, int out)
{
  int __retres;
  int *tmp;
  tmp = __errno_location();
  *tmp = 0;
  while (1) {
    
    
    
    
    if (! (insize != (unsigned int)0 && (int)insize != -1)) break;
    {
      int tmp_0;
      char *tmp_1;
      {
        /*sequence*/
        ;
        tmp_1 = convert_uint8s_sint8s(inbuf);
        ;
      }
      write_buf(out,(void *)tmp_1,insize);
      bytes_out = (long)((unsigned long)bytes_out + (unsigned long)insize);
      tmp_0 = spec_read(in,inbuf,0x8000);
      insize = (unsigned int)tmp_0;
    }
  }
  
  
  if ((int)insize == -1) {
    int *tmp_2;
    tmp_2 = __errno_location();
    
    
    if (*tmp_2 != 0) read_error();
  }
  bytes_in = bytes_out;
  __retres = 0;
  return __retres;
}

static ulg crc = 0xffffffffL;
ulg updcrc(uch *s, unsigned int n) __attribute__((__FC_OLDSTYLEPROTO__));;
ulg updcrc(uch *s, unsigned int n)
{
  ulg __retres;
  register ulg c;
  
  
  if (s == (void *)0) c = 0xffffffffL;
  else {
    c = crc;
    
    
    if (n) 
      while (1) {
        {
          uch *tmp;
          tmp = s;
          s ++;
          c = crc_32_tab[((int)c ^ (int)*tmp) & 0xff] ^ (c >> 8);
        }
        n --;
        
        
        if (! n) break;
      }
  }
  crc = c;
  __retres = c ^ 0xffffffffL;
  return __retres;
}

void clear_bufs(void)
{
  outcnt = (unsigned int)0;
  inptr = (unsigned int)0;
  insize = inptr;
  bytes_out = 0L;
  bytes_in = bytes_out;
  return;
}

int fill_inbuf(int eof_ok) __attribute__((__FC_OLDSTYLEPROTO__));;
int fill_inbuf(int eof_ok)
{
  int __retres;
  int len;
  int *tmp;
  insize = (unsigned int)0;
  tmp = __errno_location();
  *tmp = 0;
  while (1) {
    {
      unsigned char *tmp_1;
      char *tmp_0;
      {
        /*sequence*/
        ;
        {
          /*sequence*/
          tmp_0 = convert_uint8s_sint8s(inbuf);
          ;
        }
        tmp_1 = convert_sint8s_uint8s(tmp_0 + insize);
        ;
      }
      len = spec_read(ifd,tmp_1,(int)((unsigned int)0x8000 - insize));
      
      
      
      
      if (len == 0 || len == -1) break;
      insize += (unsigned int)len;
      
      
      if (! (insize < (unsigned int)0x8000)) break;
    }
  }
  
  
  if (insize == (unsigned int)0) {
    
    
    if (eof_ok) {
      __retres = -1;
      goto return_label;
    }
    read_error();
  }
  bytes_in = (long)((unsigned long)bytes_in + (unsigned long)insize);
  inptr = (unsigned int)1;
  __retres = (int)inbuf[0];
  return_label: ;
  return __retres;
}

void flush_outbuf(void)
{
  char *tmp;
  
  
  if (outcnt == (unsigned int)0) goto return_label;
  {
    /*sequence*/
    ;
    tmp = convert_uint8s_sint8s(outbuf);
    ;
  }
  write_buf(ofd,(void *)tmp,outcnt);
  bytes_out = (long)((unsigned long)bytes_out + (unsigned long)outcnt);
  outcnt = (unsigned int)0;
  return_label: ;
  return;
}

void flush_window(void)
{
  
  
  if (outcnt == (unsigned int)0) goto return_label;
  updcrc(window,outcnt);
  
  
  if (! test) {
    char *tmp;
    {
      /*sequence*/
      ;
      tmp = convert_uint8s_sint8s(window);
      ;
    }
    write_buf(ofd,(void *)tmp,outcnt);
  }
  bytes_out = (long)((unsigned long)bytes_out + (unsigned long)outcnt);
  outcnt = (unsigned int)0;
  return_label: ;
  return;
}

void write_buf(int fd, voidp buf, unsigned int cnt) __attribute__((__FC_OLDSTYLEPROTO__));;
void write_buf(int fd, voidp buf, unsigned int cnt)
{
  unsigned int n;
  while (1) {
    {
      int tmp;
      {
        unsigned char *tmp_0;
        {
          /*sequence*/
          ;
          tmp_0 = convert_sint8s_uint8s((char *)buf);
          ;
        }
        tmp = spec_write(fd,tmp_0,(int)cnt);
        n = (unsigned int)tmp;
      }
      
      
      if (! (n != cnt)) break;
      
      
      if (n == (unsigned int)(-1)) write_error();
      cnt -= n;
      buf = (void *)((char *)buf + n);
    }
  }
  return;
}

char *strlwr(char *s) __attribute__((__FC_OLDSTYLEPROTO__));;
char *strlwr(char *s)
{
  char *t;
  t = s;
  while (1) {
    {
      unsigned short const **tmp;
      
      
      if (! *t) break;
      tmp = __ctype_b_loc();
      

      

      if ((int)*(*tmp + (int)*t) & (int)((unsigned short)_ISupper)) *t = (char)(
                                                                    (
                                                                    (int)*t - 'A') + 'a');
      else *t = *t;
      t ++;
    }
  }
  return s;
}

char *gzipbasename(char *fname) __attribute__((__FC_OLDSTYLEPROTO__));;
char *gzipbasename(char *fname)
{
  char *p;
  p = strrchr((char const *)fname,'/');
  
  
  if (p != (void *)0) fname = p + 1;
  
  
  if ('A' == 'a') strlwr(fname);
  return fname;
}

void make_simple_name(char *name) __attribute__((__FC_OLDSTYLEPROTO__));;
void make_simple_name(char *name)
{
  char *p;
  p = strrchr((char const *)name,'.');
  
  
  if (p == (void *)0) goto return_label;
  
  
  if (p == name) p ++;
  while (1) {
    p --;
    
    
    if ((int)*p == '.') *p = (char)'_';
    
    
    if (! (p != name)) break;
  }
  return_label: ;
  return;
}

char *add_envopt(int *argcp, char ***argvp, char *env_0) __attribute__((
__FC_OLDSTYLEPROTO__));;
char *add_envopt(int *argcp, char ***argvp, char *env_0)
{
  char *__retres;
  char *p;
  char **oargv;
  char **nargv;
  int oargc;
  int nargc;
  voidp tmp_1;
  size_t tmp_0;
  int tmp_6;
  char **tmp_7;
  char **tmp_8;
  oargc = *argcp;
  nargc = 0;
  env_0 = getenv((char const *)env_0);
  
  
  if (env_0 == (void *)0) {
    __retres = (char *)((void *)0);
    goto return_label;
  }
  tmp_0 = strlen((char const *)env_0);
  tmp_1 = xmalloc((unsigned int)(tmp_0 + (unsigned long)1));
  p = (char *)tmp_1;
  env_0 = strcpy(p,(char const *)env_0);
  p = env_0;
  while (1) {
    
    
    if (! *p) break;
    {
      size_t tmp_2;
      size_t tmp_3;
      tmp_2 = strspn((char const *)p," \t");
      p += tmp_2;
      
      
      if ((int)*p == '\000') break;
      tmp_3 = strcspn((char const *)p," \t");
      p += tmp_3;
      
      
      if (*p) {
        char *tmp_4;
        tmp_4 = p;
        p ++;
        *tmp_4 = (char)'\000';
      }
    }
    nargc ++;
  }
  
  
  if (nargc == 0) {
    free((void *)env_0);
    __retres = (char *)((void *)0);
    goto return_label;
  }
  *argcp += nargc;
  nargv = calloc((unsigned long)(*argcp + 1),(unsigned long)sizeof(char *));
  
  
  if (nargv == (void *)0) error((char *)"out of memory");
  oargv = *argvp;
  *argvp = nargv;
  tmp_6 = oargc;
  oargc --;
  
  
  if (tmp_6 < 0) error((char *)"argc<=0");
  tmp_7 = nargv;
  nargv ++;
  tmp_8 = oargv;
  oargv ++;
  *tmp_7 = *tmp_8;
  p = env_0;
  while (1) {
    
    
    if (! (nargc > 0)) break;
    {
      size_t tmp_9;
      char **tmp_10;
      tmp_9 = strspn((char const *)p," \t");
      p += tmp_9;
      tmp_10 = nargv;
      nargv ++;
      *tmp_10 = p;
      while (1) {
        {
          char *tmp_11;
          tmp_11 = p;
          p ++;
          
          
          if (! *tmp_11) break;
        }
      }
    }
    nargc --;
  }
  while (1) {
    {
      int tmp_14;
      char **tmp_12;
      char **tmp_13;
      tmp_14 = oargc;
      oargc --;
      
      
      if (! tmp_14) break;
      tmp_12 = nargv;
      nargv ++;
      tmp_13 = oargv;
      oargv ++;
      *tmp_12 = *tmp_13;
    }
  }
  *nargv = (char *)((void *)0);
  __retres = env_0;
  return_label: ;
  return __retres;
}

void error(char *m) __attribute__((__FC_OLDSTYLEPROTO__));;
void error(char *m)
{
  fprintf(stderr,"\n%s: %s: %s\n",progname,ifname,m);
  abort_gzip();
  return;
}

void warn(char *a, char *b) __attribute__((__FC_OLDSTYLEPROTO__));;
void warn(char *a, char *b)
{
  
  
  if (! quiet) fprintf(stderr,"%s: %s: warning: %s%s\n",progname,ifname,a,b);
  
  
  if (exit_code == 0) exit_code = 2;
  return;
}

void read_error(void)
{
  int *tmp;
  fprintf(stderr,"\n%s: ",progname);
  tmp = __errno_location();
  
  
  if (*tmp != 0) perror((char const *)(ifname));
  else fprintf(stderr,"%s: unexpected end of file\n",ifname);
  abort_gzip();
  return;
}

void write_error(void)
{
  fprintf(stderr,"\n%s: ",progname);
  perror((char const *)(ofname));
  abort_gzip();
  return;
}

void display_ratio(long num, long den, FILE *file) __attribute__((__FC_OLDSTYLEPROTO__));;
void display_ratio(long num, long den, FILE *file)
{
  long ratio;
  
  
  if (den == (long)0) ratio = (long)0;
  else {
    
    
    if (den < 2147483L) ratio = (1000L * num) / den;
    else ratio = num / (den / 1000L);
  }
  
  
  if (ratio < (long)0) {
    _IO_putc('-',file);
    ratio = - ratio;
  }
  else _IO_putc(' ',file);
  fprintf(file,"%2ld.%1ld%%",ratio / 10L,ratio % 10L);
  return;
}

voidp xmalloc(unsigned int size) __attribute__((__FC_OLDSTYLEPROTO__));;
voidp xmalloc(unsigned int size)
{
  voidp cp;
  cp = malloc((unsigned long)size);
  
  
  if (cp == (void *)0) error((char *)"out of memory");
  return cp;
}

ulg crc_32_tab[256] =   
                        {(unsigned long)0x00000000L,
                         (unsigned long)0x77073096L, 0xee0e612cL,
                         0x990951baL, (unsigned long)0x076dc419L,
                         (unsigned long)0x706af48fL, 0xe963a535L,
                         0x9e6495a3L, (unsigned long)0x0edb8832L,
                         (unsigned long)0x79dcb8a4L, 0xe0d5e91eL,
                         0x97d2d988L, (unsigned long)0x09b64c2bL,
                         (unsigned long)0x7eb17cbdL, 0xe7b82d07L,
                         0x90bf1d91L, (unsigned long)0x1db71064L,
                         (unsigned long)0x6ab020f2L, 0xf3b97148L,
                         0x84be41deL, (unsigned long)0x1adad47dL,
                         (unsigned long)0x6ddde4ebL, 0xf4d4b551L,
                         0x83d385c7L, (unsigned long)0x136c9856L,
                         (unsigned long)0x646ba8c0L, 0xfd62f97aL,
                         0x8a65c9ecL, (unsigned long)0x14015c4fL,
                         (unsigned long)0x63066cd9L, 0xfa0f3d63L,
                         0x8d080df5L, (unsigned long)0x3b6e20c8L,
                         (unsigned long)0x4c69105eL, 0xd56041e4L,
                         0xa2677172L, (unsigned long)0x3c03e4d1L,
                         (unsigned long)0x4b04d447L, 0xd20d85fdL,
                         0xa50ab56bL, (unsigned long)0x35b5a8faL,
                         (unsigned long)0x42b2986cL, 0xdbbbc9d6L,
                         0xacbcf940L, (unsigned long)0x32d86ce3L,
                         (unsigned long)0x45df5c75L, 0xdcd60dcfL,
                         0xabd13d59L, (unsigned long)0x26d930acL,
                         (unsigned long)0x51de003aL, 0xc8d75180L,
                         0xbfd06116L, (unsigned long)0x21b4f4b5L,
                         (unsigned long)0x56b3c423L, 0xcfba9599L,
                         0xb8bda50fL, (unsigned long)0x2802b89eL,
                         (unsigned long)0x5f058808L, 0xc60cd9b2L,
                         0xb10be924L, (unsigned long)0x2f6f7c87L,
                         (unsigned long)0x58684c11L, 0xc1611dabL,
                         0xb6662d3dL, (unsigned long)0x76dc4190L,
                         (unsigned long)0x01db7106L, 0x98d220bcL,
                         0xefd5102aL, (unsigned long)0x71b18589L,
                         (unsigned long)0x06b6b51fL, 0x9fbfe4a5L,
                         0xe8b8d433L, (unsigned long)0x7807c9a2L,
                         (unsigned long)0x0f00f934L, 0x9609a88eL,
                         0xe10e9818L, (unsigned long)0x7f6a0dbbL,
                         (unsigned long)0x086d3d2dL, 0x91646c97L,
                         0xe6635c01L, (unsigned long)0x6b6b51f4L,
                         (unsigned long)0x1c6c6162L, 0x856530d8L,
                         0xf262004eL, (unsigned long)0x6c0695edL,
                         (unsigned long)0x1b01a57bL, 0x8208f4c1L,
                         0xf50fc457L, (unsigned long)0x65b0d9c6L,
                         (unsigned long)0x12b7e950L, 0x8bbeb8eaL,
                         0xfcb9887cL, (unsigned long)0x62dd1ddfL,
                         (unsigned long)0x15da2d49L, 0x8cd37cf3L,
                         0xfbd44c65L, (unsigned long)0x4db26158L,
                         (unsigned long)0x3ab551ceL, 0xa3bc0074L,
                         0xd4bb30e2L, (unsigned long)0x4adfa541L,
                         (unsigned long)0x3dd895d7L, 0xa4d1c46dL,
                         0xd3d6f4fbL, (unsigned long)0x4369e96aL,
                         (unsigned long)0x346ed9fcL, 0xad678846L,
                         0xda60b8d0L, (unsigned long)0x44042d73L,
                         (unsigned long)0x33031de5L, 0xaa0a4c5fL,
                         0xdd0d7cc9L, (unsigned long)0x5005713cL,
                         (unsigned long)0x270241aaL, 0xbe0b1010L,
                         0xc90c2086L, (unsigned long)0x5768b525L,
                         (unsigned long)0x206f85b3L, 0xb966d409L,
                         0xce61e49fL, (unsigned long)0x5edef90eL,
                         (unsigned long)0x29d9c998L, 0xb0d09822L,
                         0xc7d7a8b4L, (unsigned long)0x59b33d17L,
                         (unsigned long)0x2eb40d81L, 0xb7bd5c3bL,
                         0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
                         (unsigned long)0x03b6e20cL,
                         (unsigned long)0x74b1d29aL, 0xead54739L,
                         0x9dd277afL, (unsigned long)0x04db2615L,
                         (unsigned long)0x73dc1683L, 0xe3630b12L,
                         0x94643b84L, (unsigned long)0x0d6d6a3eL,
                         (unsigned long)0x7a6a5aa8L, 0xe40ecf0bL,
                         0x9309ff9dL, (unsigned long)0x0a00ae27L,
                         (unsigned long)0x7d079eb1L, 0xf00f9344L,
                         0x8708a3d2L, (unsigned long)0x1e01f268L,
                         (unsigned long)0x6906c2feL, 0xf762575dL,
                         0x806567cbL, (unsigned long)0x196c3671L,
                         (unsigned long)0x6e6b06e7L, 0xfed41b76L,
                         0x89d32be0L, (unsigned long)0x10da7a5aL,
                         (unsigned long)0x67dd4accL, 0xf9b9df6fL,
                         0x8ebeeff9L, (unsigned long)0x17b7be43L,
                         (unsigned long)0x60b08ed5L, 0xd6d6a3e8L,
                         0xa1d1937eL, (unsigned long)0x38d8c2c4L,
                         (unsigned long)0x4fdff252L, 0xd1bb67f1L,
                         0xa6bc5767L, (unsigned long)0x3fb506ddL,
                         (unsigned long)0x48b2364bL, 0xd80d2bdaL,
                         0xaf0a1b4cL, (unsigned long)0x36034af6L,
                         (unsigned long)0x41047a60L, 0xdf60efc3L,
                         0xa867df55L, (unsigned long)0x316e8eefL,
                         (unsigned long)0x4669be79L, 0xcb61b38cL,
                         0xbc66831aL, (unsigned long)0x256fd2a0L,
                         (unsigned long)0x5268e236L, 0xcc0c7795L,
                         0xbb0b4703L, (unsigned long)0x220216b9L,
                         (unsigned long)0x5505262fL, 0xc5ba3bbeL,
                         0xb2bd0b28L, (unsigned long)0x2bb45a92L,
                         (unsigned long)0x5cb36a04L, 0xc2d7ffa7L,
                         0xb5d0cf31L, (unsigned long)0x2cd99e8bL,
                         (unsigned long)0x5bdeae1dL, 0x9b64c2b0L,
                         0xec63f226L, (unsigned long)0x756aa39cL,
                         (unsigned long)0x026d930aL, 0x9c0906a9L,
                         0xeb0e363fL, (unsigned long)0x72076785L,
                         (unsigned long)0x05005713L, 0x95bf4a82L,
                         0xe2b87a14L, (unsigned long)0x7bb12baeL,
                         (unsigned long)0x0cb61b38L, 0x92d28e9bL,
                         0xe5d5be0dL, (unsigned long)0x7cdcefb7L,
                         (unsigned long)0x0bdbdf21L, 0x86d3d2d4L,
                         0xf1d4e242L, (unsigned long)0x68ddb3f8L,
                         (unsigned long)0x1fda836eL, 0x81be16cdL,
                         0xf6b9265bL, (unsigned long)0x6fb077e1L,
                         (unsigned long)0x18b74777L, 0x88085ae6L,
                         0xff0f6a70L, (unsigned long)0x66063bcaL,
                         (unsigned long)0x11010b5cL, 0x8f659effL,
                         0xf862ae69L, (unsigned long)0x616bffd3L,
                         (unsigned long)0x166ccf45L, 0xa00ae278L,
                         0xd70dd2eeL, (unsigned long)0x4e048354L,
                         (unsigned long)0x3903b3c2L, 0xa7672661L,
                         0xd06016f7L, (unsigned long)0x4969474dL,
                         (unsigned long)0x3e6e77dbL, 0xaed16a4aL,
                         0xd9d65adcL, (unsigned long)0x40df0b66L,
                         (unsigned long)0x37d83bf0L, 0xa9bcae53L,
                         0xdebb9ec5L, (unsigned long)0x47b2cf7fL,
                         (unsigned long)0x30b5ffe9L, 0xbdbdf21cL,
                         0xcabac28aL, (unsigned long)0x53b39330L,
                         (unsigned long)0x24b4a3a6L, 0xbad03605L,
                         0xcdd70693L, (unsigned long)0x54de5729L,
                         (unsigned long)0x23d967bfL, 0xb3667a2eL,
                         0xc4614ab8L, (unsigned long)0x5d681b02L,
                         (unsigned long)0x2a6f2b94L, 0xb40bbe37L,
                         0xc30c8ea1L, (unsigned long)0x5a05df1bL,
                         (unsigned long)0x2d02ef8dL};
__inline static unsigned int __bswap_75(unsigned int __bsx)
{
  unsigned int __retres;
  int tmp;
  tmp = __builtin_bswap32((int)__bsx);
  __retres = (unsigned int)tmp;
  return __retres;
}

__inline static __uint64_t __bswap_76(__uint64_t __bsx)
{
  __uint64_t __retres;
  int tmp;
  tmp = __builtin_bswap64((int)__bsx);
  __retres = (unsigned long)tmp;
  return __retres;
}

static ulg crc_0;
int zip(int in, int out) __attribute__((__FC_OLDSTYLEPROTO__));;
int zip(int in, int out)
{
  int __retres;
  uch flags_0;
  ush attr;
  ush deflate_flags;
  flags_0 = (unsigned char)0;
  attr = (unsigned short)0;
  deflate_flags = (unsigned short)0;
  ifd = in;
  ofd = out;
  outcnt = (unsigned int)0;
  method = 8;
  {
    unsigned int tmp;
    tmp = outcnt;
    outcnt ++;
    outbuf[tmp] = (unsigned char)*("\037\213" + 0);
    
    
    if (outcnt == (unsigned int)16384) flush_outbuf();
  }
  {
    unsigned int tmp_0;
    tmp_0 = outcnt;
    outcnt ++;
    outbuf[tmp_0] = (unsigned char)*("\037\213" + 1);
    
    
    if (outcnt == (unsigned int)16384) flush_outbuf();
  }
  {
    unsigned int tmp_1;
    tmp_1 = outcnt;
    outcnt ++;
    outbuf[tmp_1] = (unsigned char)8;
    
    
    if (outcnt == (unsigned int)16384) flush_outbuf();
  }
  
  
  if (save_orig_name) flags_0 = (unsigned char)((int)flags_0 | 0x08);
  {
    unsigned int tmp_2;
    tmp_2 = outcnt;
    outcnt ++;
    outbuf[tmp_2] = flags_0;
    
    
    if (outcnt == (unsigned int)16384) flush_outbuf();
  }
  
  
  if (outcnt < (unsigned int)(16384 - 2)) {
    unsigned int tmp_3;
    unsigned int tmp_4;
    tmp_3 = outcnt;
    outcnt ++;
    outbuf[tmp_3] = (unsigned char)((time_stamp & (long)0xffff) & (long)0xff);
    tmp_4 = outcnt;
    outcnt ++;
    outbuf[tmp_4] = (unsigned char)((int)((unsigned short)(time_stamp & (long)0xffff)) >> 8);
  }
  else {
    {
      unsigned int tmp_5;
      tmp_5 = outcnt;
      outcnt ++;
      outbuf[tmp_5] = (unsigned char)((time_stamp & (long)0xffff) & (long)0xff);
      
      
      if (outcnt == (unsigned int)16384) flush_outbuf();
    }
    {
      unsigned int tmp_6;
      tmp_6 = outcnt;
      outcnt ++;
      outbuf[tmp_6] = (unsigned char)((int)((unsigned short)(time_stamp & (long)0xffff)) >> 8);
      
      
      if (outcnt == (unsigned int)16384) flush_outbuf();
    }
  }
  
  
  if (outcnt < (unsigned int)(16384 - 2)) {
    unsigned int tmp_7;
    unsigned int tmp_8;
    tmp_7 = outcnt;
    outcnt ++;
    outbuf[tmp_7] = (unsigned char)(((unsigned long)time_stamp >> 16) & (unsigned long)0xff);
    tmp_8 = outcnt;
    outcnt ++;
    outbuf[tmp_8] = (unsigned char)((int)((unsigned short)((unsigned long)time_stamp >> 16)) >> 8);
  }
  else {
    {
      unsigned int tmp_9;
      tmp_9 = outcnt;
      outcnt ++;
      outbuf[tmp_9] = (unsigned char)(((unsigned long)time_stamp >> 16) & (unsigned long)0xff);
      
      
      if (outcnt == (unsigned int)16384) flush_outbuf();
    }
    {
      unsigned int tmp_10;
      tmp_10 = outcnt;
      outcnt ++;
      outbuf[tmp_10] = (unsigned char)((int)((unsigned short)((unsigned long)time_stamp >> 16)) >> 8);
      
      
      if (outcnt == (unsigned int)16384) flush_outbuf();
    }
  }
  crc_0 = updcrc((uch *)0,(unsigned int)0);
  bi_init(out);
  ct_init(& attr,& method);
  lm_init(level,& deflate_flags);
  {
    unsigned int tmp_11;
    tmp_11 = outcnt;
    outcnt ++;
    outbuf[tmp_11] = (unsigned char)deflate_flags;
    
    
    if (outcnt == (unsigned int)16384) flush_outbuf();
  }
  {
    unsigned int tmp_12;
    tmp_12 = outcnt;
    outcnt ++;
    outbuf[tmp_12] = (unsigned char)0x03;
    
    
    if (outcnt == (unsigned int)16384) flush_outbuf();
  }
  
  
  if (save_orig_name) {
    char *p;
    p = gzipbasename(ifname);
    while (1) {
      {
        char *tmp_15;
        {
          unsigned int tmp_14;
          tmp_14 = outcnt;
          outcnt ++;
          outbuf[tmp_14] = (unsigned char)*p;
          
          
          if (outcnt == (unsigned int)16384) flush_outbuf();
        }
        tmp_15 = p;
        p ++;
        
        
        if (! *tmp_15) break;
      }
    }
  }
  header_bytes = (long)outcnt;
  deflate();
  
  
  if (outcnt < (unsigned int)(16384 - 2)) {
    unsigned int tmp_16;
    unsigned int tmp_17;
    tmp_16 = outcnt;
    outcnt ++;
    outbuf[tmp_16] = (unsigned char)((crc_0 & (unsigned long)0xffff) & (unsigned long)0xff);
    tmp_17 = outcnt;
    outcnt ++;
    outbuf[tmp_17] = (unsigned char)((int)((unsigned short)(crc_0 & (unsigned long)0xffff)) >> 8);
  }
  else {
    {
      unsigned int tmp_18;
      tmp_18 = outcnt;
      outcnt ++;
      outbuf[tmp_18] = (unsigned char)((crc_0 & (unsigned long)0xffff) & (unsigned long)0xff);
      
      
      if (outcnt == (unsigned int)16384) flush_outbuf();
    }
    {
      unsigned int tmp_19;
      tmp_19 = outcnt;
      outcnt ++;
      outbuf[tmp_19] = (unsigned char)((int)((unsigned short)(crc_0 & (unsigned long)0xffff)) >> 8);
      
      
      if (outcnt == (unsigned int)16384) flush_outbuf();
    }
  }
  
  
  if (outcnt < (unsigned int)(16384 - 2)) {
    unsigned int tmp_20;
    unsigned int tmp_21;
    tmp_20 = outcnt;
    outcnt ++;
    outbuf[tmp_20] = (unsigned char)((crc_0 >> 16) & (unsigned long)0xff);
    tmp_21 = outcnt;
    outcnt ++;
    outbuf[tmp_21] = (unsigned char)((int)((unsigned short)(crc_0 >> 16)) >> 8);
  }
  else {
    {
      unsigned int tmp_22;
      tmp_22 = outcnt;
      outcnt ++;
      outbuf[tmp_22] = (unsigned char)((crc_0 >> 16) & (unsigned long)0xff);
      
      
      if (outcnt == (unsigned int)16384) flush_outbuf();
    }
    {
      unsigned int tmp_23;
      tmp_23 = outcnt;
      outcnt ++;
      outbuf[tmp_23] = (unsigned char)((int)((unsigned short)(crc_0 >> 16)) >> 8);
      
      
      if (outcnt == (unsigned int)16384) flush_outbuf();
    }
  }
  
  
  if (outcnt < (unsigned int)(16384 - 2)) {
    unsigned int tmp_24;
    unsigned int tmp_25;
    tmp_24 = outcnt;
    outcnt ++;
    outbuf[tmp_24] = (unsigned char)((bytes_in & (long)0xffff) & (long)0xff);
    tmp_25 = outcnt;
    outcnt ++;
    outbuf[tmp_25] = (unsigned char)((int)((unsigned short)(bytes_in & (long)0xffff)) >> 8);
  }
  else {
    {
      unsigned int tmp_26;
      tmp_26 = outcnt;
      outcnt ++;
      outbuf[tmp_26] = (unsigned char)((bytes_in & (long)0xffff) & (long)0xff);
      
      
      if (outcnt == (unsigned int)16384) flush_outbuf();
    }
    {
      unsigned int tmp_27;
      tmp_27 = outcnt;
      outcnt ++;
      outbuf[tmp_27] = (unsigned char)((int)((unsigned short)(bytes_in & (long)0xffff)) >> 8);
      
      
      if (outcnt == (unsigned int)16384) flush_outbuf();
    }
  }
  
  
  if (outcnt < (unsigned int)(16384 - 2)) {
    unsigned int tmp_28;
    unsigned int tmp_29;
    tmp_28 = outcnt;
    outcnt ++;
    outbuf[tmp_28] = (unsigned char)(((unsigned long)bytes_in >> 16) & (unsigned long)0xff);
    tmp_29 = outcnt;
    outcnt ++;
    outbuf[tmp_29] = (unsigned char)((int)((unsigned short)((unsigned long)bytes_in >> 16)) >> 8);
  }
  else {
    {
      unsigned int tmp_30;
      tmp_30 = outcnt;
      outcnt ++;
      outbuf[tmp_30] = (unsigned char)(((unsigned long)bytes_in >> 16) & (unsigned long)0xff);
      
      
      if (outcnt == (unsigned int)16384) flush_outbuf();
    }
    {
      unsigned int tmp_31;
      tmp_31 = outcnt;
      outcnt ++;
      outbuf[tmp_31] = (unsigned char)((int)((unsigned short)((unsigned long)bytes_in >> 16)) >> 8);
      
      
      if (outcnt == (unsigned int)16384) flush_outbuf();
    }
  }
  header_bytes = (long)((unsigned long)header_bytes + (unsigned long)(
                        (unsigned int)2 * sizeof(long)));
  flush_outbuf();
  __retres = 0;
  return __retres;
}

int file_read(char *buf, unsigned int size) __attribute__((__FC_OLDSTYLEPROTO__));;
int file_read(char *buf, unsigned int size)
{
  int __retres;
  unsigned int len;
  int tmp;
  unsigned char *tmp_1;
  {
    unsigned char *tmp_0;
    {
      /*sequence*/
      
      tmp_0 = convert_sint8s_uint8s(buf);
      
    }
    tmp = spec_read(ifd,tmp_0,(int)size);
    len = (unsigned int)tmp;
  }
  
  
  
  
  if (len == (unsigned int)(-1) || len == (unsigned int)0) {
    __retres = (int)len;
    goto return_label;
  }
  {
    /*sequence*/
    
    tmp_1 = convert_sint8s_uint8s(buf);
  }
  crc_0 = updcrc(tmp_1,len);
  bytes_in = (long)((unsigned long)bytes_in + (unsigned long)len);
  __retres = (int)len;
  return_label: ;
  return __retres;
}



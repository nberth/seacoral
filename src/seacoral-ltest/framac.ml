(**************************************************************************)
(*                                                                        *)
(*  Copyright (c) 2025 OCamlPro                                           *)
(*                                                                        *)
(*  All rights reserved.                                                  *)
(*  This file is distributed under the terms of the GNU General Public    *)
(*  License version 3.                                                    *)
(*                                                                        *)
(**************************************************************************)

open Lwt.Syntax
open Sc_sys.File.Syntax

let log_src = Logs.Src.create ~doc:"Logs of Frama-C manager" "Sc_ltest.Framac"
module Log = (val (Ez_logs.from_src log_src))

(* exception UnsupportedType of string *)
exception UnsupportedArch of string
exception BadLuncovTool of string

;;
Printexc.register_printer begin function
  | UnsupportedArch a -> Some (Format.sprintf "Unsupported architecture %s" a)
  | BadLuncovTool t -> Some (Format.sprintf "Unknown tool %s for luncov" t)
  | _ -> None
end
;;

let unsupported_arch str = raise (UnsupportedArch str)
let bad_luncov_tool tool = raise (BadLuncovTool tool)

type funs = [ `Auto of string | `All | `Only of string list ]

type lannot_opt = {
  cover_criterion: string;
  (** The coverage criterion ($ frama-c -lannot-list). *)

  annoted_functions: funs;
  (** The list of functions to annot. *)

  skipped_functions: string list;
  (** Functions that should not be annotated. *)

  output_file: string;
  (** The file generated by lannot. *)
}

type plugin =
  | LAnnot of lannot_opt
  | LUncov of {
      init : bool;
      framac_tools : string list;
      lib_entry : bool;
    }
  | Eacsl

[@@@warning "-37"]        (* ThenLast, ThenOn, and ThenReplace are not used yet *)
type then_ =
  | Then
  | ThenLast
  | ThenOn of string
  | ThenReplace

type print_options = {
  as_is : bool; (* -print-as-is *)
  ocode : string option; (* -ocode *)
}

type framac_extra = {
  cpp_extra_args: string option;
  main : string option;
  print: print_options option;
  then_ : (then_ * framac_extra) option
}

type options = {
  plugin : plugin option;
  framac_extra : framac_extra;
  (* plugin_extra_options : (string * string option) list *)
}

module Cmd = Sc_sys.Ezcmd.Make (struct
    let format_key = Format.sprintf "-%s"
    let key_value_link = Some "="
  end)

let frama_c = Cmd.make "frama-c"

let luncov_compatible_tool = [
  "eva";
  "value";
  "wp";
]

let if_none_id_otherwise f = function
  | None -> Fun.id
  | Some elt -> f elt

let is_luncov_compatible e =
  if not @@ List.mem e luncov_compatible_tool
  then bad_luncov_tool e

let print_options_to_cmd {as_is; ocode} cmd =
  cmd
  |> Cmd.if_bool "print-as-is" as_is
  |> Cmd.must_value "ocode" ocode

let rec framac_extra_to_cmd {cpp_extra_args; main; print; then_} cmd =
  cmd
  |> Cmd.optional (Some "cpp-extra-args") cpp_extra_args
  |> Cmd.key "no-c11"
  |> Cmd.must_value "main" main
  |> if_none_id_otherwise print_options_to_cmd print
  |> if_none_id_otherwise then_options then_

and then_options (then_,framac_opts) cmd =
  cmd
  |> begin match then_ with
    | Then -> Cmd.key "then"
    | ThenLast -> Cmd.key "then-last"
    | ThenOn s -> Cmd.base "then-on" s
    | ThenReplace -> Cmd.key "then-replace"
  end
  |> framac_extra_to_cmd framac_opts

let funs_to_opt selection : Cmd.t -> Cmd.t =
  match selection with
  | `All ->
      Cmd.must_value "lannot-functions" None
  | `Only funs ->
      Cmd.must_value "lannot-functions" (Some (String.concat "," funs))
  | `Auto entrypoint ->
      Cmd.must_value "lannot-with-called" (Some entrypoint)

let skipped_functions_arg = function
  | [] ->
      Fun.id
  | functions ->
      Cmd.must_value "lannot-skip-functions" (Some (String.concat "," functions))

let lannot_to_opt { cover_criterion; annoted_functions;
                    skipped_functions; output_file } cmd =
  cmd
  |> Cmd.base "lannot" cover_criterion
  |> funs_to_opt annoted_functions
  |> skipped_functions_arg skipped_functions
  |> Cmd.base "lannot-o" output_file
  |> Cmd.key "variadic-no-translation"
     (* Variadic is used in lannot and replaces functions like printf
        by non customizable aliases. This option forces variadic not to
        do that. *)
  |> Cmd.base "lannot-share"
    (* Setting the share directory of lanot by hand because it searches by default
       the directory 'lannot' while its name is 'frama-c-lannotate'. *)
    begin
      Filename.concat
        (Sc_sys.Env.get "OPAM_SWITCH_PREFIX")
        "share/frama-c/share/frama-c-lannotate"
    end

let tool_activated tool tools = List.mem tool tools
let wp_activated = tool_activated "wp"
let eva_activated tools = tool_activated "eva" tools || tool_activated "value" tools

let luncov_opt_of_tools tools cmd =
  List.iter is_luncov_compatible tools;
  let wp  = wp_activated tools
  and eva = eva_activated tools
  in
  if wp && eva
  then Cmd.key "luncov-vwap" cmd
  else if wp
  then Cmd.key "luncov-wp" cmd
  else if eva
  then Cmd.key "luncov-eva" cmd
  else cmd

let plugin_to_opt (pl : plugin) (cmd : Cmd.t) : Cmd.t = match pl with
  | LAnnot user_options ->
      cmd
      |> lannot_to_opt user_options

  | LUncov {init; framac_tools; lib_entry} ->
      cmd
      |> Cmd.key "luncov"
      |> Cmd.if_bool "luncov-init" init
      |> luncov_opt_of_tools framac_tools
      |> Cmd.if_bool "lib-entry" lib_entry
      |> Cmd.base "luncov-share"
        (* Setting the share directory of lanot by hand because it searches by default
           the directory 'lannot' while its name is 'frama-c-lannotate'. *)
        begin
          Filename.concat
            (Sc_sys.Env.get "OPAM_SWITCH_PREFIX")
            "share/frama-c/share/frama-c-luncov"
        end

  | Eacsl -> cmd |> Cmd.key "e-acsl"

(* Concatenates all the options *)
let cmd_options (opt : options) (cmd : Cmd.t): Cmd.t =
  cmd
  |> if_none_id_otherwise plugin_to_opt opt.plugin
  |> framac_extra_to_cmd opt.framac_extra

(* Returns the Frama-C command line given the options *)
let frama_c_cmd (opt : options) (files : [> `C] Sc_sys.File.t list) : Cmd.t =
  let frama_c_and_files =
    List.fold_left
      (fun cmd file -> Cmd.raw (Sc_sys.File.name file) cmd)
      frama_c
      files
  in
  frama_c_and_files
  |> cmd_options opt

let cpp_extra_args ?(include_dirs = []) (module C: Types.CONFIG) : string Lwt.t =
  Lwt.return @@
  Format.asprintf "%a"
    (Basics.PPrt.pp_lst ~fopen:"'" ~fclose:"'" ~fsep:"' '" @@ Fmt.fmt "-I'%s'")
    ("." :: List.map Sc_sys.File.name (include_dirs @ C.config.header_dirs))

let lannot_cmd (module C : Types.CONFIG)
    ?include_dirs
    ~cover_criterion
    ~annoted_functions
    ~skipped_functions
    ~output_file
    (file : [> `C] Sc_sys.File.t) :
  Sc_sys.Process.command Lwt.t =
  let* opts =
    let* framac_extra =
      let* cpp_extra_args = cpp_extra_args ?include_dirs (module C) in Lwt.return {
        cpp_extra_args = Some cpp_extra_args;
        main = None;
        then_ = None;
        print = None;
      }
    in
    Lwt.return {
      framac_extra;
      plugin = Some (LAnnot { cover_criterion; annoted_functions;
                              skipped_functions; output_file })
    }
  in
  Lwt.return (Cmd.to_cmd (frama_c_cmd opts [file]))

let luncov_init (module C : Types.CONFIG)
    (files : [> `C] Sc_sys.File.t list) : Sc_sys.Process.command Lwt.t =
  let* framac_extra =
    let* cpp_extra_args = cpp_extra_args (module C) in Lwt.return {
      cpp_extra_args = Some cpp_extra_args;
      main = None;
      then_ = None;
      print = None;
    }
  in
  let plugin = Some (LUncov {init = true; framac_tools = []; lib_entry = false}) in
  let opts = {framac_extra; plugin; } in
  Lwt.return @@ Cmd.to_cmd @@ frama_c_cmd opts files


(* !Files must be the lannot generated files! *)
let luncov_cmd
    (module C : Types.CONFIG)
    ?(main_name : string option)
    ~(framac_tools : string list)
    ~(extra_args : string list)
    (files : [> `C] Sc_sys.File.t list) : Sc_sys.Process.command Lwt.t =
  let* cmd =
    let plugin = Some (LUncov {init = false; framac_tools; lib_entry = true}) in
    let* framac_extra =
      let* cpp_extra_args = cpp_extra_args (module C) in Lwt.return {
        cpp_extra_args = Some cpp_extra_args;
        main = main_name;
        then_ = None;
        print = None;
      }
    in
    let opts = {
      plugin;
      framac_extra;
    } in
    Lwt.return @@ frama_c_cmd opts files
  in
  let cmd_with_extra =
    List.fold_left (fun cmd s ->  match Scanf.sscanf s "%s@:%s" (fun k v -> k, v) with
        | k, "" -> Cmd.key k cmd
        | k, v -> Cmd.base k v cmd
        | exception Scanf.Scan_failure _ when s = "" -> cmd
      )
      cmd
      extra_args
  in
  Lwt.return @@ Cmd.to_cmd cmd_with_extra


(* !Files must be the lannot generated files! *)
let eacsl_cmd
    (module C : Types.CONFIG)
    ?(main_name : string option)
    ~(output : string)
    (files : [> `C] Sc_sys.File.t list) : Sc_sys.Process.command Lwt.t =
  let plugin = Some Eacsl in
  let* framac_extra =
    let* cpp_extra_args = cpp_extra_args (module C) in Lwt.return {
      cpp_extra_args = Some cpp_extra_args;
      main = main_name;
      then_ = Some (Then, {
          cpp_extra_args = None;
          main = None;
          then_ = None;
          print = Some {as_is = false; ocode = Some output}
        });
      print = None;
    }
  in
  let opts = {
    plugin;
    framac_extra;
  } in
  Lwt.return @@ Cmd.to_cmd @@ frama_c_cmd opts files

let check_option ~errlog option_name =
  let* option_explained =
    let* proc =
      Sc_sys.Process.exec (frama_c |>
                           Cmd.key "explain" |>
                           Cmd.key option_name |>
                           Cmd.to_cmd)
        ~log_command:`On_error
        ~stderr:(`Log errlog)
        ~stdout:`Keep
        ~on_success:Lwt.return
    in
    Sc_sys.Process.stdout_lines proc |>
    Lwt_stream.find (String.starts_with ~prefix:("-" ^ option_name))
  in
  Lwt.return (option_explained <> None)

let luncov_installed () =
  Sc_sys.Process.exec_status (frama_c |> Cmd.key "luncov-h" |> Cmd.to_cmd)

let eacsl_installed () =
  Sc_sys.Process.exec_status (frama_c |> Cmd.key "e-acsl-h" |> Cmd.to_cmd)

module Arch = struct
  (** Frama-C compatible architectures *)
  type t =
    | GCC_X86_64
    | GCC_X86_32
    | GCC_X86_16
    | X86_64
    | X86_32
    | X86_16
    | PPC_32
    | MSCV_X86_64

  let of_string str =
    match String.lowercase_ascii str with
    | "gcc_x86_64"
    | "gcc-x86-64" -> GCC_X86_64

    | "gcc_x86_32"
    | "gcc-x86-32" -> GCC_X86_32

    | "gcc_x86_16"
    | "gcc-x86-16" -> GCC_X86_32

    | "x86_64"
    | "x86-64" -> X86_64

    | "x86_32"
    | "x86-32" -> X86_32

    | "x86_16"
    | "x86-16" -> X86_32

    | "ppc_32"
    | "ppc-32" -> PPC_32

    | "mscv_x86_64"
    | "mscv-x86-64" -> MSCV_X86_64

    | _ -> unsupported_arch str

  let to_fc_string = function
    | GCC_X86_64 -> "__FC_MACHDEP_GCC_X86_64"
    | GCC_X86_32 -> "__FC_MACHDEP_GCC_X86_32"
    | GCC_X86_16 -> "__FC_MACHDEP_GCC_X86_16"
    | X86_64 -> "__FC_MACHDEP_X86_64"
    | X86_32 -> "__FC_MACHDEP_X86_32"
    | X86_16 -> "__FC_MACHDEP_X86_16"
    | PPC_32 -> "__FC_MACHDEP_PPC_32"
    | MSCV_X86_64 -> "__FC_MACHDEP_MSVC_X86_64"

  let to_pretty_string = function
    | GCC_X86_64 -> "gcc-x86-64"
    | GCC_X86_32 -> "gcc-x86-32"
    | GCC_X86_16 -> "gcc-x86-16"
    | X86_64 -> "x86-64"
    | X86_32 -> "x86-32"
    | X86_16 -> "x86-16"
    | PPC_32 -> "ppc-32"
    | MSCV_X86_64 -> "mscv-x86-64"
end

let framac_builtin = Str.regexp {|\(.*\)__fc_\([A-za-z0-9_]+\)\(.*\)$|}

let remove_framac_builtins_from_string s =
  Str.global_replace framac_builtin {|\1\2\3|} s

let remove_framac_builtins_from_file (f : [> `C] Sc_sys.File.t) =
  (* TODO: lwt-ize (also use [Lwt_io.with_temp_file]) *)
  let tmp_file =
    Sc_sys.File.create_empty_in ~dir:(Sc_sys.File.dir f) "__tmp.c"
  in
  (* Creating new file with no framac_builtins *)
  begin
    let> out_chan = tmp_file in
    let< in_chan = f in
    try
      while true do
        let line = input_line in_chan in
        let new_line = remove_framac_builtins_from_string line in
        Stdlib.output_string out_chan new_line;
        Stdlib.output_char out_chan '\n'
      done
    with
    | End_of_file -> ()
  end;
  let f' =
    Sc_sys.File.rename_replace
      ~old_file:tmp_file
      ~new_basename:(Sc_sys.File.basename f)
  in
  assert (Sc_sys.File.absname f = Sc_sys.File.absname f');
  ()
